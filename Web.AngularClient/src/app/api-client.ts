//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class DeviceTypeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getDevicesPaginated(pageIndex: number | undefined, pageSize: number | undefined): Observable<ServicePaginatedResultOfDeviceType> {
        let url_ = this.baseUrl + "/api/DeviceType/GetDevicesPaginated?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDevicesPaginated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDevicesPaginated(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServicePaginatedResultOfDeviceType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServicePaginatedResultOfDeviceType>;
        }));
    }

    protected processGetDevicesPaginated(response: HttpResponseBase): Observable<ServicePaginatedResultOfDeviceType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServicePaginatedResultOfDeviceType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addDeviceType(number: string | null | undefined, name: string | null | undefined, notation: string | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/DeviceType/AddDeviceType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (number !== null && number !== undefined)
            content_.append("Number", number.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (notation !== null && notation !== undefined)
            content_.append("Notation", notation.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDeviceType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDeviceType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processAddDeviceType(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InitialVerificationJobsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getJobs(pageIndex: number | undefined, pageSize: number | undefined): Observable<ServicePaginatedResultOfInitialVerificationJob> {
        let url_ = this.baseUrl + "/api/InitialVerificationJobs/GetJobs?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServicePaginatedResultOfInitialVerificationJob>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServicePaginatedResultOfInitialVerificationJob>;
        }));
    }

    protected processGetJobs(response: HttpResponseBase): Observable<ServicePaginatedResultOfInitialVerificationJob> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServicePaginatedResultOfInitialVerificationJob.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addJob(year: number | undefined, month: number | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/InitialVerificationJobs/AddJob";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (year === null || year === undefined)
            throw new Error("The parameter 'year' cannot be null.");
        else
            content_.append("Year", year.toString());
        if (month === null || month === undefined)
            throw new Error("The parameter 'month' cannot be null.");
        else
            content_.append("Month", month.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddJob(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processAddJob(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteJob(id: string | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/InitialVerificationJobs/DeleteJob?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteJob(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processDeleteJob(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OwnersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getOwners(pageIndex: number | undefined, pageSize: number | undefined): Observable<ServicePaginatedResultOfOwner> {
        let url_ = this.baseUrl + "/api/Owners/GetOwners?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOwners(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOwners(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServicePaginatedResultOfOwner>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServicePaginatedResultOfOwner>;
        }));
    }

    protected processGetOwners(response: HttpResponseBase): Observable<ServicePaginatedResultOfOwner> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServicePaginatedResultOfOwner.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addOwner(name: string | null | undefined, iNN: number | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/Owners/AddOwner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (iNN === null || iNN === undefined)
            throw new Error("The parameter 'iNN' cannot be null.");
        else
            content_.append("INN", iNN.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOwner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOwner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processAddOwner(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setOwnerINN(id: string | undefined, iNN: number | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/Owners/SetOwnerINN";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (iNN === null || iNN === undefined)
            throw new Error("The parameter 'iNN' cannot be null.");
        else
            content_.append("INN", iNN.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetOwnerINN(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetOwnerINN(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processSetOwnerINN(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProtocolTemplateClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getTemplates(pageIndex: number | undefined, pageSize: number | undefined): Observable<ServicePaginatedResultOfProtocolTemplateDTO> {
        let url_ = this.baseUrl + "/api/ProtocolTemplate/GetTemplates?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServicePaginatedResultOfProtocolTemplateDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServicePaginatedResultOfProtocolTemplateDTO>;
        }));
    }

    protected processGetTemplates(response: HttpResponseBase): Observable<ServicePaginatedResultOfProtocolTemplateDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServicePaginatedResultOfProtocolTemplateDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPossibleVerificationMethods(pageIndex: number | undefined, pageSize: number | undefined): Observable<ServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO> {
        let url_ = this.baseUrl + "/api/ProtocolTemplate/GetPossibleVerificationMethods?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPossibleVerificationMethods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPossibleVerificationMethods(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO>;
        }));
    }

    protected processGetPossibleVerificationMethods(response: HttpResponseBase): Observable<ServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addTemplate(verificationGroup: string | null | undefined, protocolGroup: string | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/ProtocolTemplate/AddTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (verificationGroup !== null && verificationGroup !== undefined)
            content_.append("VerificationGroup", verificationGroup.toString());
        if (protocolGroup !== null && protocolGroup !== undefined)
            content_.append("ProtocolGroup", protocolGroup.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processAddTemplate(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteTemplate(id: string | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/ProtocolTemplate/DeleteTemplate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processDeleteTemplate(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class VerificationMethodsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getVerificationMethods(pageIndex: number | undefined, pageSize: number | undefined): Observable<ServicePaginatedResultOfVerificationMethodDTO> {
        let url_ = this.baseUrl + "/api/VerificationMethods/GetVerificationMethods?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVerificationMethods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVerificationMethods(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServicePaginatedResultOfVerificationMethodDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServicePaginatedResultOfVerificationMethodDTO>;
        }));
    }

    protected processGetVerificationMethods(response: HttpResponseBase): Observable<ServicePaginatedResultOfVerificationMethodDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServicePaginatedResultOfVerificationMethodDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPossibleVerificationMethods(pageIndex: number | undefined, pageSize: number | undefined, deviceTypeNumberFilter: string | null | undefined, verificationNameFilter: string | null | undefined, deviceTypeInfoFilter: string | null | undefined, yearMonthFilter: string | null | undefined): Observable<ServicePaginatedResultOfPossibleVerificationMethodDTO> {
        let url_ = this.baseUrl + "/api/VerificationMethods/GetPossibleVerificationMethods?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (deviceTypeNumberFilter !== undefined && deviceTypeNumberFilter !== null)
            url_ += "DeviceTypeNumberFilter=" + encodeURIComponent("" + deviceTypeNumberFilter) + "&";
        if (verificationNameFilter !== undefined && verificationNameFilter !== null)
            url_ += "VerificationNameFilter=" + encodeURIComponent("" + verificationNameFilter) + "&";
        if (deviceTypeInfoFilter !== undefined && deviceTypeInfoFilter !== null)
            url_ += "DeviceTypeInfoFilter=" + encodeURIComponent("" + deviceTypeInfoFilter) + "&";
        if (yearMonthFilter !== undefined && yearMonthFilter !== null)
            url_ += "YearMonthFilter=" + encodeURIComponent("" + yearMonthFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPossibleVerificationMethods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPossibleVerificationMethods(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServicePaginatedResultOfPossibleVerificationMethodDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServicePaginatedResultOfPossibleVerificationMethodDTO>;
        }));
    }

    protected processGetPossibleVerificationMethods(response: HttpResponseBase): Observable<ServicePaginatedResultOfPossibleVerificationMethodDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServicePaginatedResultOfPossibleVerificationMethodDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addVerificationMethod(fileName: string | null | undefined, file: FileParameter | null | undefined, description: string | null | undefined, aliases: string[] | null | undefined, checkups: { [key in keyof typeof VerificationMethodCheckups]?: string; } | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/VerificationMethods/AddVerificationMethod";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (fileName !== null && fileName !== undefined)
            content_.append("FileName", fileName.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");
        if (description !== null && description !== undefined)
            content_.append("Description", description.toString());
        if (aliases !== null && aliases !== undefined)
            aliases.forEach(item_ => content_.append("Aliases", item_.toString()));
        if (checkups !== null && checkups !== undefined)
            content_.append("Checkups", JSON.stringify(checkups));

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddVerificationMethod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddVerificationMethod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processAddVerificationMethod(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addAliases(aliases: string[] | null | undefined, verificationMethodId: string | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/VerificationMethods/AddAliases";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (aliases !== null && aliases !== undefined)
            aliases.forEach(item_ => content_.append("Aliases", item_.toString()));
        if (verificationMethodId === null || verificationMethodId === undefined)
            throw new Error("The parameter 'verificationMethodId' cannot be null.");
        else
            content_.append("VerificationMethodId", verificationMethodId.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAliases(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAliases(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processAddAliases(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    downloadFile(fileId: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/VerificationMethods/DownloadFile?";
        if (fileId === null)
            throw new Error("The parameter 'fileId' cannot be null.");
        else if (fileId !== undefined)
            url_ += "fileId=" + encodeURIComponent("" + fileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadFile(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class VerificationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getInitialVerifications(pageIndex: number | undefined, pageSize: number | undefined, deviceTypeNumber: string | null | undefined, yearMonth: string | null | undefined, typeInfo: string | null | undefined, location: DeviceLocation | null | undefined): Observable<ServicePaginatedResultOfSuccessInitialVerificationDto> {
        let url_ = this.baseUrl + "/api/Verifications/GetInitialVerifications?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (deviceTypeNumber !== undefined && deviceTypeNumber !== null)
            url_ += "DeviceTypeNumber=" + encodeURIComponent("" + deviceTypeNumber) + "&";
        if (yearMonth !== undefined && yearMonth !== null)
            url_ += "YearMonth=" + encodeURIComponent("" + yearMonth) + "&";
        if (typeInfo !== undefined && typeInfo !== null)
            url_ += "TypeInfo=" + encodeURIComponent("" + typeInfo) + "&";
        if (location !== undefined && location !== null)
            url_ += "Location=" + encodeURIComponent("" + location) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInitialVerifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInitialVerifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServicePaginatedResultOfSuccessInitialVerificationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServicePaginatedResultOfSuccessInitialVerificationDto>;
        }));
    }

    protected processGetInitialVerifications(response: HttpResponseBase): Observable<ServicePaginatedResultOfSuccessInitialVerificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServicePaginatedResultOfSuccessInitialVerificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getVerifications(pageIndex: number | undefined, pageSize: number | undefined, deviceTypeNumber: string | null | undefined, yearMonth: string | null | undefined, typeInfo: string | null | undefined, location: DeviceLocation | null | undefined): Observable<ServicePaginatedResultOfSuccessVerificationDto> {
        let url_ = this.baseUrl + "/api/Verifications/GetVerifications?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (deviceTypeNumber !== undefined && deviceTypeNumber !== null)
            url_ += "DeviceTypeNumber=" + encodeURIComponent("" + deviceTypeNumber) + "&";
        if (yearMonth !== undefined && yearMonth !== null)
            url_ += "YearMonth=" + encodeURIComponent("" + yearMonth) + "&";
        if (typeInfo !== undefined && typeInfo !== null)
            url_ += "TypeInfo=" + encodeURIComponent("" + typeInfo) + "&";
        if (location !== undefined && location !== null)
            url_ += "Location=" + encodeURIComponent("" + location) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVerifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVerifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServicePaginatedResultOfSuccessVerificationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServicePaginatedResultOfSuccessVerificationDto>;
        }));
    }

    protected processGetVerifications(response: HttpResponseBase): Observable<ServicePaginatedResultOfSuccessVerificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServicePaginatedResultOfSuccessVerificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setValues(excelFile: FileParameter | null | undefined, sheetName: string | null | undefined, dataRange: string | null | undefined, location: string | null | undefined, group: string | null | undefined, verificationTypeNum: boolean | null | undefined, worker: boolean | null | undefined, pressure: boolean | null | undefined, temperature: boolean | null | undefined, humidity: boolean | null | undefined, measurementRange: boolean | null | undefined, accuracy: boolean | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/Verifications/SetValues";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (excelFile !== null && excelFile !== undefined)
            content_.append("excelFile", excelFile.data, excelFile.fileName ? excelFile.fileName : "excelFile");
        if (sheetName !== null && sheetName !== undefined)
            content_.append("SheetName", sheetName.toString());
        if (dataRange !== null && dataRange !== undefined)
            content_.append("DataRange", dataRange.toString());
        if (location !== null && location !== undefined)
            content_.append("Location", location.toString());
        if (group !== null && group !== undefined)
            content_.append("Group", group.toString());
        if (verificationTypeNum !== null && verificationTypeNum !== undefined)
            content_.append("VerificationTypeNum", verificationTypeNum.toString());
        if (worker !== null && worker !== undefined)
            content_.append("Worker", worker.toString());
        if (pressure !== null && pressure !== undefined)
            content_.append("Pressure", pressure.toString());
        if (temperature !== null && temperature !== undefined)
            content_.append("Temperature", temperature.toString());
        if (humidity !== null && humidity !== undefined)
            content_.append("Humidity", humidity.toString());
        if (measurementRange !== null && measurementRange !== undefined)
            content_.append("MeasurementRange", measurementRange.toString());
        if (accuracy !== null && accuracy !== undefined)
            content_.append("Accuracy", accuracy.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processSetValues(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setVerificationNum(sheetName: string | undefined, excelFile: FileParameter | null | undefined, dataRange: string | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/Verifications/SetVerificationNum?";
        if (sheetName === null)
            throw new Error("The parameter 'sheetName' cannot be null.");
        else if (sheetName !== undefined)
            url_ += "sheetName=" + encodeURIComponent("" + sheetName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (excelFile !== null && excelFile !== undefined)
            content_.append("excelFile", excelFile.data, excelFile.fileName ? excelFile.fileName : "excelFile");
        if (dataRange !== null && dataRange !== undefined)
            content_.append("dataRange", dataRange.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetVerificationNum(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetVerificationNum(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processSetVerificationNum(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ServicePaginatedResultOfDeviceType implements IServicePaginatedResultOfDeviceType {
    message?: string | null;
    error?: string | null;
    data?: PaginatedListOfDeviceType | null;

    constructor(data?: IServicePaginatedResultOfDeviceType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
            this.data = _data["data"] ? PaginatedListOfDeviceType.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): ServicePaginatedResultOfDeviceType {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePaginatedResultOfDeviceType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data;
    }
}

export interface IServicePaginatedResultOfDeviceType {
    message?: string | null;
    error?: string | null;
    data?: PaginatedListOfDeviceType | null;
}

export class PaginatedListOfDeviceType implements IPaginatedListOfDeviceType {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: DeviceType[];

    constructor(data?: IPaginatedListOfDeviceType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"] !== undefined ? _data["pageIndex"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceType.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
        }
    }

    static fromJS(data: any): PaginatedListOfDeviceType {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfDeviceType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>null);
        }
        return data;
    }
}

export interface IPaginatedListOfDeviceType {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: DeviceType[];
}

export abstract class DatabaseEntity implements IDatabaseEntity {
    id?: string;

    constructor(data?: IDatabaseEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): DatabaseEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'DatabaseEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data;
    }
}

export interface IDatabaseEntity {
    id?: string;
}

export class DeviceType extends DatabaseEntity implements IDeviceType {
    number?: string;
    title?: string;
    notation?: string;
    verificationMethodId?: string | null;
    verificationMethod?: VerificationMethod | null;

    constructor(data?: IDeviceType) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.number = _data["number"] !== undefined ? _data["number"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.notation = _data["notation"] !== undefined ? _data["notation"] : <any>null;
            this.verificationMethodId = _data["verificationMethodId"] !== undefined ? _data["verificationMethodId"] : <any>null;
            this.verificationMethod = _data["verificationMethod"] ? VerificationMethod.fromJS(_data["verificationMethod"]) : <any>null;
        }
    }

    static override fromJS(data: any): DeviceType {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceType();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number !== undefined ? this.number : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["notation"] = this.notation !== undefined ? this.notation : <any>null;
        data["verificationMethodId"] = this.verificationMethodId !== undefined ? this.verificationMethodId : <any>null;
        data["verificationMethod"] = this.verificationMethod ? this.verificationMethod.toJSON() : <any>null;
        super.toJSON(data);
        return data;
    }
}

export interface IDeviceType extends IDatabaseEntity {
    number?: string;
    title?: string;
    notation?: string;
    verificationMethodId?: string | null;
    verificationMethod?: VerificationMethod | null;
}

export class VerificationMethod extends DatabaseEntity implements IVerificationMethod {
    aliases?: string[];
    description?: string;
    checkups?: { [key in keyof typeof VerificationMethodCheckups]?: string; };
    protocolTemplateId?: string | null;
    verificationMethodFiles?: VerificationMethodFile[] | null;
    deviceTypes?: DeviceType[] | null;

    constructor(data?: IVerificationMethod) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["aliases"])) {
                this.aliases = [] as any;
                for (let item of _data["aliases"])
                    this.aliases!.push(item);
            }
            else {
                this.aliases = <any>null;
            }
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            if (_data["checkups"]) {
                this.checkups = {} as any;
                for (let key in _data["checkups"]) {
                    if (_data["checkups"].hasOwnProperty(key))
                        (<any>this.checkups)![key] = _data["checkups"][key] !== undefined ? _data["checkups"][key] : <any>null;
                }
            }
            else {
                this.checkups = <any>null;
            }
            this.protocolTemplateId = _data["protocolTemplateId"] !== undefined ? _data["protocolTemplateId"] : <any>null;
            if (Array.isArray(_data["verificationMethodFiles"])) {
                this.verificationMethodFiles = [] as any;
                for (let item of _data["verificationMethodFiles"])
                    this.verificationMethodFiles!.push(VerificationMethodFile.fromJS(item));
            }
            else {
                this.verificationMethodFiles = <any>null;
            }
            if (Array.isArray(_data["deviceTypes"])) {
                this.deviceTypes = [] as any;
                for (let item of _data["deviceTypes"])
                    this.deviceTypes!.push(DeviceType.fromJS(item));
            }
            else {
                this.deviceTypes = <any>null;
            }
        }
    }

    static override fromJS(data: any): VerificationMethod {
        data = typeof data === 'object' ? data : {};
        let result = new VerificationMethod();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.aliases)) {
            data["aliases"] = [];
            for (let item of this.aliases)
                data["aliases"].push(item);
        }
        data["description"] = this.description !== undefined ? this.description : <any>null;
        if (this.checkups) {
            data["checkups"] = {};
            for (let key in this.checkups) {
                if (this.checkups.hasOwnProperty(key))
                    (<any>data["checkups"])[key] = this.checkups[key] !== undefined ? this.checkups[key] : <any>null;
            }
        }
        data["protocolTemplateId"] = this.protocolTemplateId !== undefined ? this.protocolTemplateId : <any>null;
        if (Array.isArray(this.verificationMethodFiles)) {
            data["verificationMethodFiles"] = [];
            for (let item of this.verificationMethodFiles)
                data["verificationMethodFiles"].push(item ? item.toJSON() : <any>null);
        }
        if (Array.isArray(this.deviceTypes)) {
            data["deviceTypes"] = [];
            for (let item of this.deviceTypes)
                data["deviceTypes"].push(item ? item.toJSON() : <any>null);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IVerificationMethod extends IDatabaseEntity {
    aliases?: string[];
    description?: string;
    checkups?: { [key in keyof typeof VerificationMethodCheckups]?: string; };
    protocolTemplateId?: string | null;
    verificationMethodFiles?: VerificationMethodFile[] | null;
    deviceTypes?: DeviceType[] | null;
}

export enum VerificationMethodCheckups {
    Visual = "visual",
    Result = "result",
    Accuracy = "accuracy",
}

export class VerificationMethodFile extends DatabaseEntity implements IVerificationMethodFile {
    fileName?: string;
    mimetype?: string;
    content?: string;

    constructor(data?: IVerificationMethodFile) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fileName = _data["fileName"] !== undefined ? _data["fileName"] : <any>null;
            this.mimetype = _data["mimetype"] !== undefined ? _data["mimetype"] : <any>null;
            this.content = _data["content"] !== undefined ? _data["content"] : <any>null;
        }
    }

    static override fromJS(data: any): VerificationMethodFile {
        data = typeof data === 'object' ? data : {};
        let result = new VerificationMethodFile();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName !== undefined ? this.fileName : <any>null;
        data["mimetype"] = this.mimetype !== undefined ? this.mimetype : <any>null;
        data["content"] = this.content !== undefined ? this.content : <any>null;
        super.toJSON(data);
        return data;
    }
}

export interface IVerificationMethodFile extends IDatabaseEntity {
    fileName?: string;
    mimetype?: string;
    content?: string;
}

export class ServiceResult implements IServiceResult {
    message?: string | null;
    error?: string | null;

    constructor(data?: IServiceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
        }
    }

    static fromJS(data: any): ServiceResult {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        return data;
    }
}

export interface IServiceResult {
    message?: string | null;
    error?: string | null;
}

export class ServicePaginatedResultOfInitialVerificationJob implements IServicePaginatedResultOfInitialVerificationJob {
    message?: string | null;
    error?: string | null;
    data?: PaginatedListOfInitialVerificationJob | null;

    constructor(data?: IServicePaginatedResultOfInitialVerificationJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
            this.data = _data["data"] ? PaginatedListOfInitialVerificationJob.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): ServicePaginatedResultOfInitialVerificationJob {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePaginatedResultOfInitialVerificationJob();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data;
    }
}

export interface IServicePaginatedResultOfInitialVerificationJob {
    message?: string | null;
    error?: string | null;
    data?: PaginatedListOfInitialVerificationJob | null;
}

export class PaginatedListOfInitialVerificationJob implements IPaginatedListOfInitialVerificationJob {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: InitialVerificationJob[];

    constructor(data?: IPaginatedListOfInitialVerificationJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"] !== undefined ? _data["pageIndex"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InitialVerificationJob.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
        }
    }

    static fromJS(data: any): PaginatedListOfInitialVerificationJob {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfInitialVerificationJob();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>null);
        }
        return data;
    }
}

export interface IPaginatedListOfInitialVerificationJob {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: InitialVerificationJob[];
}

export class InitialVerificationJob extends DatabaseEntity implements IInitialVerificationJob {
    date?: YearMonth;

    constructor(data?: IInitialVerificationJob) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.date = _data["date"] ? YearMonth.fromJS(_data["date"]) : <any>null;
        }
    }

    static override fromJS(data: any): InitialVerificationJob {
        data = typeof data === 'object' ? data : {};
        let result = new InitialVerificationJob();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toJSON() : <any>null;
        super.toJSON(data);
        return data;
    }
}

export interface IInitialVerificationJob extends IDatabaseEntity {
    date?: YearMonth;
}

export class YearMonth implements IYearMonth {
    year?: number;
    month?: number;

    constructor(data?: IYearMonth) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"] !== undefined ? _data["year"] : <any>null;
            this.month = _data["month"] !== undefined ? _data["month"] : <any>null;
        }
    }

    static fromJS(data: any): YearMonth {
        data = typeof data === 'object' ? data : {};
        let result = new YearMonth();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year !== undefined ? this.year : <any>null;
        data["month"] = this.month !== undefined ? this.month : <any>null;
        return data;
    }
}

export interface IYearMonth {
    year?: number;
    month?: number;
}

export class ServicePaginatedResultOfOwner implements IServicePaginatedResultOfOwner {
    message?: string | null;
    error?: string | null;
    data?: PaginatedListOfOwner | null;

    constructor(data?: IServicePaginatedResultOfOwner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
            this.data = _data["data"] ? PaginatedListOfOwner.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): ServicePaginatedResultOfOwner {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePaginatedResultOfOwner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data;
    }
}

export interface IServicePaginatedResultOfOwner {
    message?: string | null;
    error?: string | null;
    data?: PaginatedListOfOwner | null;
}

export class PaginatedListOfOwner implements IPaginatedListOfOwner {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: Owner[];

    constructor(data?: IPaginatedListOfOwner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"] !== undefined ? _data["pageIndex"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Owner.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
        }
    }

    static fromJS(data: any): PaginatedListOfOwner {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfOwner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>null);
        }
        return data;
    }
}

export interface IPaginatedListOfOwner {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: Owner[];
}

export class Owner extends DatabaseEntity implements IOwner {
    name?: string;
    inn?: number;

    constructor(data?: IOwner) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.inn = _data["inn"] !== undefined ? _data["inn"] : <any>null;
        }
    }

    static override fromJS(data: any): Owner {
        data = typeof data === 'object' ? data : {};
        let result = new Owner();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["inn"] = this.inn !== undefined ? this.inn : <any>null;
        super.toJSON(data);
        return data;
    }
}

export interface IOwner extends IDatabaseEntity {
    name?: string;
    inn?: number;
}

export class ServicePaginatedResultOfProtocolTemplateDTO implements IServicePaginatedResultOfProtocolTemplateDTO {
    message?: string | null;
    error?: string | null;
    data?: PaginatedListOfProtocolTemplateDTO | null;

    constructor(data?: IServicePaginatedResultOfProtocolTemplateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
            this.data = _data["data"] ? PaginatedListOfProtocolTemplateDTO.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): ServicePaginatedResultOfProtocolTemplateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePaginatedResultOfProtocolTemplateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data;
    }
}

export interface IServicePaginatedResultOfProtocolTemplateDTO {
    message?: string | null;
    error?: string | null;
    data?: PaginatedListOfProtocolTemplateDTO | null;
}

export class PaginatedListOfProtocolTemplateDTO implements IPaginatedListOfProtocolTemplateDTO {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: ProtocolTemplateDTO[];

    constructor(data?: IPaginatedListOfProtocolTemplateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"] !== undefined ? _data["pageIndex"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProtocolTemplateDTO.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
        }
    }

    static fromJS(data: any): PaginatedListOfProtocolTemplateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProtocolTemplateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>null);
        }
        return data;
    }
}

export interface IPaginatedListOfProtocolTemplateDTO {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: ProtocolTemplateDTO[];
}

export class ProtocolTemplateDTO implements IProtocolTemplateDTO {
    id?: string;
    protocolGroup?: ProtocolGroup;
    verificationGroup?: VerificationGroup;
    verificationMethodIds?: string[];

    constructor(data?: IProtocolTemplateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.protocolGroup = _data["protocolGroup"] !== undefined ? _data["protocolGroup"] : <any>null;
            this.verificationGroup = _data["verificationGroup"] !== undefined ? _data["verificationGroup"] : <any>null;
            if (Array.isArray(_data["verificationMethodIds"])) {
                this.verificationMethodIds = [] as any;
                for (let item of _data["verificationMethodIds"])
                    this.verificationMethodIds!.push(item);
            }
            else {
                this.verificationMethodIds = <any>null;
            }
        }
    }

    static fromJS(data: any): ProtocolTemplateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProtocolTemplateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["protocolGroup"] = this.protocolGroup !== undefined ? this.protocolGroup : <any>null;
        data["verificationGroup"] = this.verificationGroup !== undefined ? this.verificationGroup : <any>null;
        if (Array.isArray(this.verificationMethodIds)) {
            data["verificationMethodIds"] = [];
            for (let item of this.verificationMethodIds)
                data["verificationMethodIds"].push(item);
        }
        return data;
    }
}

export interface IProtocolTemplateDTO {
    id?: string;
    protocolGroup?: ProtocolGroup;
    verificationGroup?: VerificationGroup;
    verificationMethodIds?: string[];
}

export enum ProtocolGroup {
    1 = "1",
}

export enum VerificationGroup {
     = "",
    _ = "_",
    _ = "_",
}

export class ServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO implements IServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO {
    message?: string | null;
    error?: string | null;
    data?: PaginatedListOfPossibleTemplateVerificationMethodsDTO | null;

    constructor(data?: IServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
            this.data = _data["data"] ? PaginatedListOfPossibleTemplateVerificationMethodsDTO.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): ServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data;
    }
}

export interface IServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO {
    message?: string | null;
    error?: string | null;
    data?: PaginatedListOfPossibleTemplateVerificationMethodsDTO | null;
}

export class PaginatedListOfPossibleTemplateVerificationMethodsDTO implements IPaginatedListOfPossibleTemplateVerificationMethodsDTO {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: PossibleTemplateVerificationMethodsDTO[];

    constructor(data?: IPaginatedListOfPossibleTemplateVerificationMethodsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"] !== undefined ? _data["pageIndex"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PossibleTemplateVerificationMethodsDTO.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
        }
    }

    static fromJS(data: any): PaginatedListOfPossibleTemplateVerificationMethodsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfPossibleTemplateVerificationMethodsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>null);
        }
        return data;
    }
}

export interface IPaginatedListOfPossibleTemplateVerificationMethodsDTO {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: PossibleTemplateVerificationMethodsDTO[];
}

export class PossibleTemplateVerificationMethodsDTO implements IPossibleTemplateVerificationMethodsDTO {
    protocolGroup?: ProtocolGroup;
    verificationMethod?: VerificationMethod;

    constructor(data?: IPossibleTemplateVerificationMethodsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.protocolGroup = _data["protocolGroup"] !== undefined ? _data["protocolGroup"] : <any>null;
            this.verificationMethod = _data["verificationMethod"] ? VerificationMethod.fromJS(_data["verificationMethod"]) : <any>null;
        }
    }

    static fromJS(data: any): PossibleTemplateVerificationMethodsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PossibleTemplateVerificationMethodsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["protocolGroup"] = this.protocolGroup !== undefined ? this.protocolGroup : <any>null;
        data["verificationMethod"] = this.verificationMethod ? this.verificationMethod.toJSON() : <any>null;
        return data;
    }
}

export interface IPossibleTemplateVerificationMethodsDTO {
    protocolGroup?: ProtocolGroup;
    verificationMethod?: VerificationMethod;
}

export class ServicePaginatedResultOfVerificationMethodDTO implements IServicePaginatedResultOfVerificationMethodDTO {
    message?: string | null;
    error?: string | null;
    data?: PaginatedListOfVerificationMethodDTO | null;

    constructor(data?: IServicePaginatedResultOfVerificationMethodDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
            this.data = _data["data"] ? PaginatedListOfVerificationMethodDTO.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): ServicePaginatedResultOfVerificationMethodDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePaginatedResultOfVerificationMethodDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data;
    }
}

export interface IServicePaginatedResultOfVerificationMethodDTO {
    message?: string | null;
    error?: string | null;
    data?: PaginatedListOfVerificationMethodDTO | null;
}

export class PaginatedListOfVerificationMethodDTO implements IPaginatedListOfVerificationMethodDTO {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: VerificationMethodDTO[];

    constructor(data?: IPaginatedListOfVerificationMethodDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"] !== undefined ? _data["pageIndex"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(VerificationMethodDTO.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
        }
    }

    static fromJS(data: any): PaginatedListOfVerificationMethodDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfVerificationMethodDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>null);
        }
        return data;
    }
}

export interface IPaginatedListOfVerificationMethodDTO {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: VerificationMethodDTO[];
}

export class VerificationMethodDTO implements IVerificationMethodDTO {
    id?: string;
    aliases?: string[];
    description?: string;
    files?: string[];
    typeNumbers?: string[];

    constructor(data?: IVerificationMethodDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            if (Array.isArray(_data["aliases"])) {
                this.aliases = [] as any;
                for (let item of _data["aliases"])
                    this.aliases!.push(item);
            }
            else {
                this.aliases = <any>null;
            }
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(item);
            }
            else {
                this.files = <any>null;
            }
            if (Array.isArray(_data["typeNumbers"])) {
                this.typeNumbers = [] as any;
                for (let item of _data["typeNumbers"])
                    this.typeNumbers!.push(item);
            }
            else {
                this.typeNumbers = <any>null;
            }
        }
    }

    static fromJS(data: any): VerificationMethodDTO {
        data = typeof data === 'object' ? data : {};
        let result = new VerificationMethodDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        if (Array.isArray(this.aliases)) {
            data["aliases"] = [];
            for (let item of this.aliases)
                data["aliases"].push(item);
        }
        data["description"] = this.description !== undefined ? this.description : <any>null;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item);
        }
        if (Array.isArray(this.typeNumbers)) {
            data["typeNumbers"] = [];
            for (let item of this.typeNumbers)
                data["typeNumbers"].push(item);
        }
        return data;
    }
}

export interface IVerificationMethodDTO {
    id?: string;
    aliases?: string[];
    description?: string;
    files?: string[];
    typeNumbers?: string[];
}

export class ServicePaginatedResultOfPossibleVerificationMethodDTO implements IServicePaginatedResultOfPossibleVerificationMethodDTO {
    message?: string | null;
    error?: string | null;
    data?: PaginatedListOfPossibleVerificationMethodDTO | null;

    constructor(data?: IServicePaginatedResultOfPossibleVerificationMethodDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
            this.data = _data["data"] ? PaginatedListOfPossibleVerificationMethodDTO.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): ServicePaginatedResultOfPossibleVerificationMethodDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePaginatedResultOfPossibleVerificationMethodDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data;
    }
}

export interface IServicePaginatedResultOfPossibleVerificationMethodDTO {
    message?: string | null;
    error?: string | null;
    data?: PaginatedListOfPossibleVerificationMethodDTO | null;
}

export class PaginatedListOfPossibleVerificationMethodDTO implements IPaginatedListOfPossibleVerificationMethodDTO {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: PossibleVerificationMethodDTO[];

    constructor(data?: IPaginatedListOfPossibleVerificationMethodDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"] !== undefined ? _data["pageIndex"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PossibleVerificationMethodDTO.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
        }
    }

    static fromJS(data: any): PaginatedListOfPossibleVerificationMethodDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfPossibleVerificationMethodDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>null);
        }
        return data;
    }
}

export interface IPaginatedListOfPossibleVerificationMethodDTO {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: PossibleVerificationMethodDTO[];
}

export class PossibleVerificationMethodDTO implements IPossibleVerificationMethodDTO {
    deviceTypeNumber?: string;
    deviceTypeInfo?: string;
    verificationMethodId?: string | null;
    deviceModifications?: string[];
    verificationTypeNames?: string[];
    dates?: YearMonth[];

    constructor(data?: IPossibleVerificationMethodDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceTypeNumber = _data["deviceTypeNumber"] !== undefined ? _data["deviceTypeNumber"] : <any>null;
            this.deviceTypeInfo = _data["deviceTypeInfo"] !== undefined ? _data["deviceTypeInfo"] : <any>null;
            this.verificationMethodId = _data["verificationMethodId"] !== undefined ? _data["verificationMethodId"] : <any>null;
            if (Array.isArray(_data["deviceModifications"])) {
                this.deviceModifications = [] as any;
                for (let item of _data["deviceModifications"])
                    this.deviceModifications!.push(item);
            }
            else {
                this.deviceModifications = <any>null;
            }
            if (Array.isArray(_data["verificationTypeNames"])) {
                this.verificationTypeNames = [] as any;
                for (let item of _data["verificationTypeNames"])
                    this.verificationTypeNames!.push(item);
            }
            else {
                this.verificationTypeNames = <any>null;
            }
            if (Array.isArray(_data["dates"])) {
                this.dates = [] as any;
                for (let item of _data["dates"])
                    this.dates!.push(YearMonth.fromJS(item));
            }
            else {
                this.dates = <any>null;
            }
        }
    }

    static fromJS(data: any): PossibleVerificationMethodDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PossibleVerificationMethodDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceTypeNumber"] = this.deviceTypeNumber !== undefined ? this.deviceTypeNumber : <any>null;
        data["deviceTypeInfo"] = this.deviceTypeInfo !== undefined ? this.deviceTypeInfo : <any>null;
        data["verificationMethodId"] = this.verificationMethodId !== undefined ? this.verificationMethodId : <any>null;
        if (Array.isArray(this.deviceModifications)) {
            data["deviceModifications"] = [];
            for (let item of this.deviceModifications)
                data["deviceModifications"].push(item);
        }
        if (Array.isArray(this.verificationTypeNames)) {
            data["verificationTypeNames"] = [];
            for (let item of this.verificationTypeNames)
                data["verificationTypeNames"].push(item);
        }
        if (Array.isArray(this.dates)) {
            data["dates"] = [];
            for (let item of this.dates)
                data["dates"].push(item ? item.toJSON() : <any>null);
        }
        return data;
    }
}

export interface IPossibleVerificationMethodDTO {
    deviceTypeNumber?: string;
    deviceTypeInfo?: string;
    verificationMethodId?: string | null;
    deviceModifications?: string[];
    verificationTypeNames?: string[];
    dates?: YearMonth[];
}

export class ServicePaginatedResultOfSuccessInitialVerificationDto implements IServicePaginatedResultOfSuccessInitialVerificationDto {
    message?: string | null;
    error?: string | null;
    data?: PaginatedListOfSuccessInitialVerificationDto | null;

    constructor(data?: IServicePaginatedResultOfSuccessInitialVerificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
            this.data = _data["data"] ? PaginatedListOfSuccessInitialVerificationDto.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): ServicePaginatedResultOfSuccessInitialVerificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePaginatedResultOfSuccessInitialVerificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data;
    }
}

export interface IServicePaginatedResultOfSuccessInitialVerificationDto {
    message?: string | null;
    error?: string | null;
    data?: PaginatedListOfSuccessInitialVerificationDto | null;
}

export class PaginatedListOfSuccessInitialVerificationDto implements IPaginatedListOfSuccessInitialVerificationDto {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: SuccessInitialVerificationDto[];

    constructor(data?: IPaginatedListOfSuccessInitialVerificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"] !== undefined ? _data["pageIndex"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SuccessInitialVerificationDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
        }
    }

    static fromJS(data: any): PaginatedListOfSuccessInitialVerificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfSuccessInitialVerificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>null);
        }
        return data;
    }
}

export interface IPaginatedListOfSuccessInitialVerificationDto {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: SuccessInitialVerificationDto[];
}

export class SuccessInitialVerificationDto implements ISuccessInitialVerificationDto {
    deviceTypeNumber?: string;
    deviceSerial?: string;
    verificationDate?: Date;
    verifiedUntilDate?: Date;
    verificationTypeName?: string;
    owner?: string;
    id?: string;
    deviceTypeInfo?: string;
    etalons?: string[];
    verificationGroup?: VerificationGroup | null;
    protocolNumber?: string | null;
    ownerINN?: number | null;
    worker?: string | null;
    location?: DeviceLocation | null;
    pressure?: string | null;
    temperature?: number | null;
    humidity?: number | null;
    measurementMin?: number | null;
    measurementMax?: number | null;
    measurementUnit?: string | null;
    accuracy?: number | null;

    constructor(data?: ISuccessInitialVerificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceTypeNumber = _data["deviceTypeNumber"] !== undefined ? _data["deviceTypeNumber"] : <any>null;
            this.deviceSerial = _data["deviceSerial"] !== undefined ? _data["deviceSerial"] : <any>null;
            this.verificationDate = _data["verificationDate"] ? new Date(_data["verificationDate"].toString()) : <any>null;
            this.verifiedUntilDate = _data["verifiedUntilDate"] ? new Date(_data["verifiedUntilDate"].toString()) : <any>null;
            this.verificationTypeName = _data["verificationTypeName"] !== undefined ? _data["verificationTypeName"] : <any>null;
            this.owner = _data["owner"] !== undefined ? _data["owner"] : <any>null;
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deviceTypeInfo = _data["deviceTypeInfo"] !== undefined ? _data["deviceTypeInfo"] : <any>null;
            if (Array.isArray(_data["etalons"])) {
                this.etalons = [] as any;
                for (let item of _data["etalons"])
                    this.etalons!.push(item);
            }
            else {
                this.etalons = <any>null;
            }
            this.verificationGroup = _data["verificationGroup"] !== undefined ? _data["verificationGroup"] : <any>null;
            this.protocolNumber = _data["protocolNumber"] !== undefined ? _data["protocolNumber"] : <any>null;
            this.ownerINN = _data["ownerINN"] !== undefined ? _data["ownerINN"] : <any>null;
            this.worker = _data["worker"] !== undefined ? _data["worker"] : <any>null;
            this.location = _data["location"] !== undefined ? _data["location"] : <any>null;
            this.pressure = _data["pressure"] !== undefined ? _data["pressure"] : <any>null;
            this.temperature = _data["temperature"] !== undefined ? _data["temperature"] : <any>null;
            this.humidity = _data["humidity"] !== undefined ? _data["humidity"] : <any>null;
            this.measurementMin = _data["measurementMin"] !== undefined ? _data["measurementMin"] : <any>null;
            this.measurementMax = _data["measurementMax"] !== undefined ? _data["measurementMax"] : <any>null;
            this.measurementUnit = _data["measurementUnit"] !== undefined ? _data["measurementUnit"] : <any>null;
            this.accuracy = _data["accuracy"] !== undefined ? _data["accuracy"] : <any>null;
        }
    }

    static fromJS(data: any): SuccessInitialVerificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SuccessInitialVerificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceTypeNumber"] = this.deviceTypeNumber !== undefined ? this.deviceTypeNumber : <any>null;
        data["deviceSerial"] = this.deviceSerial !== undefined ? this.deviceSerial : <any>null;
        data["verificationDate"] = this.verificationDate ? formatDate(this.verificationDate) : <any>null;
        data["verifiedUntilDate"] = this.verifiedUntilDate ? formatDate(this.verifiedUntilDate) : <any>null;
        data["verificationTypeName"] = this.verificationTypeName !== undefined ? this.verificationTypeName : <any>null;
        data["owner"] = this.owner !== undefined ? this.owner : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deviceTypeInfo"] = this.deviceTypeInfo !== undefined ? this.deviceTypeInfo : <any>null;
        if (Array.isArray(this.etalons)) {
            data["etalons"] = [];
            for (let item of this.etalons)
                data["etalons"].push(item);
        }
        data["verificationGroup"] = this.verificationGroup !== undefined ? this.verificationGroup : <any>null;
        data["protocolNumber"] = this.protocolNumber !== undefined ? this.protocolNumber : <any>null;
        data["ownerINN"] = this.ownerINN !== undefined ? this.ownerINN : <any>null;
        data["worker"] = this.worker !== undefined ? this.worker : <any>null;
        data["location"] = this.location !== undefined ? this.location : <any>null;
        data["pressure"] = this.pressure !== undefined ? this.pressure : <any>null;
        data["temperature"] = this.temperature !== undefined ? this.temperature : <any>null;
        data["humidity"] = this.humidity !== undefined ? this.humidity : <any>null;
        data["measurementMin"] = this.measurementMin !== undefined ? this.measurementMin : <any>null;
        data["measurementMax"] = this.measurementMax !== undefined ? this.measurementMax : <any>null;
        data["measurementUnit"] = this.measurementUnit !== undefined ? this.measurementUnit : <any>null;
        data["accuracy"] = this.accuracy !== undefined ? this.accuracy : <any>null;
        return data;
    }
}

export interface ISuccessInitialVerificationDto {
    deviceTypeNumber?: string;
    deviceSerial?: string;
    verificationDate?: Date;
    verifiedUntilDate?: Date;
    verificationTypeName?: string;
    owner?: string;
    id?: string;
    deviceTypeInfo?: string;
    etalons?: string[];
    verificationGroup?: VerificationGroup | null;
    protocolNumber?: string | null;
    ownerINN?: number | null;
    worker?: string | null;
    location?: DeviceLocation | null;
    pressure?: string | null;
    temperature?: number | null;
    humidity?: number | null;
    measurementMin?: number | null;
    measurementMax?: number | null;
    measurementUnit?: string | null;
    accuracy?: number | null;
}

export enum DeviceLocation {
     = "",
     = "",
}

export class ServicePaginatedResultOfSuccessVerificationDto implements IServicePaginatedResultOfSuccessVerificationDto {
    message?: string | null;
    error?: string | null;
    data?: PaginatedListOfSuccessVerificationDto | null;

    constructor(data?: IServicePaginatedResultOfSuccessVerificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
            this.data = _data["data"] ? PaginatedListOfSuccessVerificationDto.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): ServicePaginatedResultOfSuccessVerificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePaginatedResultOfSuccessVerificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data;
    }
}

export interface IServicePaginatedResultOfSuccessVerificationDto {
    message?: string | null;
    error?: string | null;
    data?: PaginatedListOfSuccessVerificationDto | null;
}

export class PaginatedListOfSuccessVerificationDto implements IPaginatedListOfSuccessVerificationDto {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: SuccessVerificationDto[];

    constructor(data?: IPaginatedListOfSuccessVerificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"] !== undefined ? _data["pageIndex"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SuccessVerificationDto.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
        }
    }

    static fromJS(data: any): PaginatedListOfSuccessVerificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfSuccessVerificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>null);
        }
        return data;
    }
}

export interface IPaginatedListOfSuccessVerificationDto {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: SuccessVerificationDto[];
}

export class SuccessVerificationDto implements ISuccessVerificationDto {
    id?: string;
    deviceTypeNumber?: string;
    deviceSerial?: string;
    verificationDate?: Date;
    verificationGroup?: VerificationGroup;
    deviceTypeInfo?: string;
    verifiedUntilDate?: Date;
    verificationTypeName?: string;
    owner?: string;
    etalons?: string[];
    protocolNumber?: string;
    ownerInn?: number;
    worker?: string;
    location?: DeviceLocation;
    pressure?: string;
    temperature?: number;
    humidity?: number;
    measurementMin?: number;
    measurementMax?: number;
    measurementUnit?: string;
    accuracy?: number;

    constructor(data?: ISuccessVerificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.deviceTypeNumber = _data["deviceTypeNumber"] !== undefined ? _data["deviceTypeNumber"] : <any>null;
            this.deviceSerial = _data["deviceSerial"] !== undefined ? _data["deviceSerial"] : <any>null;
            this.verificationDate = _data["verificationDate"] ? new Date(_data["verificationDate"].toString()) : <any>null;
            this.verificationGroup = _data["verificationGroup"] !== undefined ? _data["verificationGroup"] : <any>null;
            this.deviceTypeInfo = _data["deviceTypeInfo"] !== undefined ? _data["deviceTypeInfo"] : <any>null;
            this.verifiedUntilDate = _data["verifiedUntilDate"] ? new Date(_data["verifiedUntilDate"].toString()) : <any>null;
            this.verificationTypeName = _data["verificationTypeName"] !== undefined ? _data["verificationTypeName"] : <any>null;
            this.owner = _data["owner"] !== undefined ? _data["owner"] : <any>null;
            if (Array.isArray(_data["etalons"])) {
                this.etalons = [] as any;
                for (let item of _data["etalons"])
                    this.etalons!.push(item);
            }
            else {
                this.etalons = <any>null;
            }
            this.protocolNumber = _data["protocolNumber"] !== undefined ? _data["protocolNumber"] : <any>null;
            this.ownerInn = _data["ownerInn"] !== undefined ? _data["ownerInn"] : <any>null;
            this.worker = _data["worker"] !== undefined ? _data["worker"] : <any>null;
            this.location = _data["location"] !== undefined ? _data["location"] : <any>null;
            this.pressure = _data["pressure"] !== undefined ? _data["pressure"] : <any>null;
            this.temperature = _data["temperature"] !== undefined ? _data["temperature"] : <any>null;
            this.humidity = _data["humidity"] !== undefined ? _data["humidity"] : <any>null;
            this.measurementMin = _data["measurementMin"] !== undefined ? _data["measurementMin"] : <any>null;
            this.measurementMax = _data["measurementMax"] !== undefined ? _data["measurementMax"] : <any>null;
            this.measurementUnit = _data["measurementUnit"] !== undefined ? _data["measurementUnit"] : <any>null;
            this.accuracy = _data["accuracy"] !== undefined ? _data["accuracy"] : <any>null;
        }
    }

    static fromJS(data: any): SuccessVerificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SuccessVerificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["deviceTypeNumber"] = this.deviceTypeNumber !== undefined ? this.deviceTypeNumber : <any>null;
        data["deviceSerial"] = this.deviceSerial !== undefined ? this.deviceSerial : <any>null;
        data["verificationDate"] = this.verificationDate ? formatDate(this.verificationDate) : <any>null;
        data["verificationGroup"] = this.verificationGroup !== undefined ? this.verificationGroup : <any>null;
        data["deviceTypeInfo"] = this.deviceTypeInfo !== undefined ? this.deviceTypeInfo : <any>null;
        data["verifiedUntilDate"] = this.verifiedUntilDate ? formatDate(this.verifiedUntilDate) : <any>null;
        data["verificationTypeName"] = this.verificationTypeName !== undefined ? this.verificationTypeName : <any>null;
        data["owner"] = this.owner !== undefined ? this.owner : <any>null;
        if (Array.isArray(this.etalons)) {
            data["etalons"] = [];
            for (let item of this.etalons)
                data["etalons"].push(item);
        }
        data["protocolNumber"] = this.protocolNumber !== undefined ? this.protocolNumber : <any>null;
        data["ownerInn"] = this.ownerInn !== undefined ? this.ownerInn : <any>null;
        data["worker"] = this.worker !== undefined ? this.worker : <any>null;
        data["location"] = this.location !== undefined ? this.location : <any>null;
        data["pressure"] = this.pressure !== undefined ? this.pressure : <any>null;
        data["temperature"] = this.temperature !== undefined ? this.temperature : <any>null;
        data["humidity"] = this.humidity !== undefined ? this.humidity : <any>null;
        data["measurementMin"] = this.measurementMin !== undefined ? this.measurementMin : <any>null;
        data["measurementMax"] = this.measurementMax !== undefined ? this.measurementMax : <any>null;
        data["measurementUnit"] = this.measurementUnit !== undefined ? this.measurementUnit : <any>null;
        data["accuracy"] = this.accuracy !== undefined ? this.accuracy : <any>null;
        return data;
    }
}

export interface ISuccessVerificationDto {
    id?: string;
    deviceTypeNumber?: string;
    deviceSerial?: string;
    verificationDate?: Date;
    verificationGroup?: VerificationGroup;
    deviceTypeInfo?: string;
    verifiedUntilDate?: Date;
    verificationTypeName?: string;
    owner?: string;
    etalons?: string[];
    protocolNumber?: string;
    ownerInn?: number;
    worker?: string;
    location?: DeviceLocation;
    pressure?: string;
    temperature?: number;
    humidity?: number;
    measurementMin?: number;
    measurementMax?: number;
    measurementUnit?: string;
    accuracy?: number;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}