//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class DavlenieClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getVerifications(pageIndex: number | undefined, pageSize: number | undefined, deviceTypeNumber: string | null | undefined, deviceSerial: string | null | undefined, yearMonth: string | null | undefined, location: DeviceLocation | null | undefined): Observable<ServicePaginatedResultOfDavlenie1VerificationDTO> {
        let url_ = this.baseUrl + "/api/Davlenie/GetVerifications?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (deviceTypeNumber !== undefined && deviceTypeNumber !== null)
            url_ += "DeviceTypeNumber=" + encodeURIComponent("" + deviceTypeNumber) + "&";
        if (deviceSerial !== undefined && deviceSerial !== null)
            url_ += "DeviceSerial=" + encodeURIComponent("" + deviceSerial) + "&";
        if (yearMonth !== undefined && yearMonth !== null)
            url_ += "YearMonth=" + encodeURIComponent("" + yearMonth) + "&";
        if (location !== undefined && location !== null)
            url_ += "Location=" + encodeURIComponent("" + location) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVerifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVerifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServicePaginatedResultOfDavlenie1VerificationDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServicePaginatedResultOfDavlenie1VerificationDTO>;
        }));
    }

    protected processGetVerifications(response: HttpResponseBase): Observable<ServicePaginatedResultOfDavlenie1VerificationDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServicePaginatedResultOfDavlenie1VerificationDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteVerifications(ids: string[]): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/Davlenie/DeleteVerifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVerifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVerifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processDeleteVerifications(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DeviceTypeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getDevicesPaginated(pageIndex: number | undefined, pageSize: number | undefined): Observable<ServicePaginatedResultOfDeviceType> {
        let url_ = this.baseUrl + "/api/DeviceType/GetDevicesPaginated?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDevicesPaginated(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDevicesPaginated(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServicePaginatedResultOfDeviceType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServicePaginatedResultOfDeviceType>;
        }));
    }

    protected processGetDevicesPaginated(response: HttpResponseBase): Observable<ServicePaginatedResultOfDeviceType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServicePaginatedResultOfDeviceType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addDeviceType(number: string | null | undefined, title: string | null | undefined, notation: string | null | undefined, mPI: number | undefined, methodUrls: string[] | null | undefined, specUrls: string[] | null | undefined, manufacturers: string[] | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/DeviceType/AddDeviceType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (number !== null && number !== undefined)
            content_.append("Number", number.toString());
        if (title !== null && title !== undefined)
            content_.append("Title", title.toString());
        if (notation !== null && notation !== undefined)
            content_.append("Notation", notation.toString());
        if (mPI === null || mPI === undefined)
            throw new Error("The parameter 'mPI' cannot be null.");
        else
            content_.append("MPI", mPI.toString());
        if (methodUrls !== null && methodUrls !== undefined)
            methodUrls.forEach(item_ => content_.append("MethodUrls", item_.toString()));
        if (specUrls !== null && specUrls !== undefined)
            specUrls.forEach(item_ => content_.append("SpecUrls", item_.toString()));
        if (manufacturers !== null && manufacturers !== undefined)
            manufacturers.forEach(item_ => content_.append("Manufacturers", item_.toString()));

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDeviceType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDeviceType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processAddDeviceType(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ExportToPdfClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    exportToPdf(request: ExportToPdfRequest): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/ExportToPdf/ExportToPdf";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToPdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToPdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processExportToPdf(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportAllToPdf(group: VerificationGroup | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/ExportToPdf/ExportAllToPdf?";
        if (group === null)
            throw new Error("The parameter 'group' cannot be null.");
        else if (group !== undefined)
            url_ += "group=" + encodeURIComponent("" + group) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportAllToPdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportAllToPdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processExportAllToPdf(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportByExcelToPDF(group: string | null | undefined, file: FileParameter | null | undefined, sheetName: string | null | undefined, dataRange: string | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/ExportToPdf/ExportByExcelToPDF";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (group !== null && group !== undefined)
            content_.append("Group", group.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");
        if (sheetName !== null && sheetName !== undefined)
            content_.append("SheetName", sheetName.toString());
        if (dataRange !== null && dataRange !== undefined)
            content_.append("DataRange", dataRange.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportByExcelToPDF(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportByExcelToPDF(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processExportByExcelToPDF(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InitialVerificationJobsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getJobs(pageIndex: number | undefined, pageSize: number | undefined): Observable<ServicePaginatedResultOfInitialVerificationJob> {
        let url_ = this.baseUrl + "/api/InitialVerificationJobs/GetJobs?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServicePaginatedResultOfInitialVerificationJob>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServicePaginatedResultOfInitialVerificationJob>;
        }));
    }

    protected processGetJobs(response: HttpResponseBase): Observable<ServicePaginatedResultOfInitialVerificationJob> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServicePaginatedResultOfInitialVerificationJob.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addJob(year: number | undefined, month: number | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/InitialVerificationJobs/AddJob";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (year === null || year === undefined)
            throw new Error("The parameter 'year' cannot be null.");
        else
            content_.append("Year", year.toString());
        if (month === null || month === undefined)
            throw new Error("The parameter 'month' cannot be null.");
        else
            content_.append("Month", month.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddJob(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processAddJob(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteJob(id: string | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/InitialVerificationJobs/DeleteJob?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteJob(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processDeleteJob(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ManometrClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getVerifications(pageIndex: number | undefined, pageSize: number | undefined, deviceTypeNumber: string | null | undefined, deviceSerial: string | null | undefined, yearMonth: string | null | undefined, location: DeviceLocation | null | undefined): Observable<ServicePaginatedResultOfManometr1VerificationDto> {
        let url_ = this.baseUrl + "/api/Manometr/GetVerifications?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (deviceTypeNumber !== undefined && deviceTypeNumber !== null)
            url_ += "DeviceTypeNumber=" + encodeURIComponent("" + deviceTypeNumber) + "&";
        if (deviceSerial !== undefined && deviceSerial !== null)
            url_ += "DeviceSerial=" + encodeURIComponent("" + deviceSerial) + "&";
        if (yearMonth !== undefined && yearMonth !== null)
            url_ += "YearMonth=" + encodeURIComponent("" + yearMonth) + "&";
        if (location !== undefined && location !== null)
            url_ += "Location=" + encodeURIComponent("" + location) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVerifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVerifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServicePaginatedResultOfManometr1VerificationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServicePaginatedResultOfManometr1VerificationDto>;
        }));
    }

    protected processGetVerifications(response: HttpResponseBase): Observable<ServicePaginatedResultOfManometr1VerificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServicePaginatedResultOfManometr1VerificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteVerifications(ids: string[]): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/Manometr/DeleteVerifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVerifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVerifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processDeleteVerifications(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OwnersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getOwners(pageIndex: number | undefined, pageSize: number | undefined): Observable<ServicePaginatedResultOfOwner> {
        let url_ = this.baseUrl + "/api/Owners/GetOwners?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOwners(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOwners(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServicePaginatedResultOfOwner>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServicePaginatedResultOfOwner>;
        }));
    }

    protected processGetOwners(response: HttpResponseBase): Observable<ServicePaginatedResultOfOwner> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServicePaginatedResultOfOwner.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addOwner(name: string | null | undefined, iNN: number | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/Owners/AddOwner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (iNN === null || iNN === undefined)
            throw new Error("The parameter 'iNN' cannot be null.");
        else
            content_.append("INN", iNN.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOwner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOwner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processAddOwner(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setOwnerINN(id: string | undefined, iNN: number | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/Owners/SetOwnerINN";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (id === null || id === undefined)
            throw new Error("The parameter 'id' cannot be null.");
        else
            content_.append("Id", id.toString());
        if (iNN === null || iNN === undefined)
            throw new Error("The parameter 'iNN' cannot be null.");
        else
            content_.append("INN", iNN.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetOwnerINN(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetOwnerINN(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processSetOwnerINN(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProtocolTemplateClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getTemplates(pageIndex: number | undefined, pageSize: number | undefined): Observable<ServicePaginatedResultOfProtocolTemplateDTO> {
        let url_ = this.baseUrl + "/api/ProtocolTemplate/GetTemplates?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServicePaginatedResultOfProtocolTemplateDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServicePaginatedResultOfProtocolTemplateDTO>;
        }));
    }

    protected processGetTemplates(response: HttpResponseBase): Observable<ServicePaginatedResultOfProtocolTemplateDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServicePaginatedResultOfProtocolTemplateDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPossibleVerificationMethods(pageIndex: number | undefined, pageSize: number | undefined): Observable<ServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO> {
        let url_ = this.baseUrl + "/api/ProtocolTemplate/GetPossibleVerificationMethods?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPossibleVerificationMethods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPossibleVerificationMethods(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO>;
        }));
    }

    protected processGetPossibleVerificationMethods(response: HttpResponseBase): Observable<ServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addTemplate(verificationGroup: string | null | undefined, protocolGroup: string | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/ProtocolTemplate/AddTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (verificationGroup !== null && verificationGroup !== undefined)
            content_.append("VerificationGroup", verificationGroup.toString());
        if (protocolGroup !== null && protocolGroup !== undefined)
            content_.append("ProtocolGroup", protocolGroup.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processAddTemplate(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addVerificationMethod(templateId: string | undefined, verificationMethodId: string | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/ProtocolTemplate/AddVerificationMethod";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (templateId === null || templateId === undefined)
            throw new Error("The parameter 'templateId' cannot be null.");
        else
            content_.append("TemplateId", templateId.toString());
        if (verificationMethodId === null || verificationMethodId === undefined)
            throw new Error("The parameter 'verificationMethodId' cannot be null.");
        else
            content_.append("VerificationMethodId", verificationMethodId.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddVerificationMethod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddVerificationMethod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processAddVerificationMethod(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteTemplate(id: string | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/ProtocolTemplate/DeleteTemplate?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processDeleteTemplate(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class VerificationMethodsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getVerificationMethods(pageIndex: number | undefined, pageSize: number | undefined): Observable<ServicePaginatedResultOfVerificationMethodDTO> {
        let url_ = this.baseUrl + "/api/VerificationMethods/GetVerificationMethods?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVerificationMethods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVerificationMethods(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServicePaginatedResultOfVerificationMethodDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServicePaginatedResultOfVerificationMethodDTO>;
        }));
    }

    protected processGetVerificationMethods(response: HttpResponseBase): Observable<ServicePaginatedResultOfVerificationMethodDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServicePaginatedResultOfVerificationMethodDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPossibleVerificationMethods(pageIndex: number | undefined, pageSize: number | undefined, showVMethods: ShowVMethods | undefined, deviceTypeNumberFilter: string | null | undefined, verificationNameFilter: string | null | undefined, deviceTypeInfoFilter: string | null | undefined, yearMonthFilter: string | null | undefined): Observable<ServicePaginatedResultOfPossibleVrfMethodDTO> {
        let url_ = this.baseUrl + "/api/VerificationMethods/GetPossibleVerificationMethods?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (showVMethods === null)
            throw new Error("The parameter 'showVMethods' cannot be null.");
        else if (showVMethods !== undefined)
            url_ += "ShowVMethods=" + encodeURIComponent("" + showVMethods) + "&";
        if (deviceTypeNumberFilter !== undefined && deviceTypeNumberFilter !== null)
            url_ += "DeviceTypeNumberFilter=" + encodeURIComponent("" + deviceTypeNumberFilter) + "&";
        if (verificationNameFilter !== undefined && verificationNameFilter !== null)
            url_ += "VerificationNameFilter=" + encodeURIComponent("" + verificationNameFilter) + "&";
        if (deviceTypeInfoFilter !== undefined && deviceTypeInfoFilter !== null)
            url_ += "DeviceTypeInfoFilter=" + encodeURIComponent("" + deviceTypeInfoFilter) + "&";
        if (yearMonthFilter !== undefined && yearMonthFilter !== null)
            url_ += "YearMonthFilter=" + encodeURIComponent("" + yearMonthFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPossibleVerificationMethods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPossibleVerificationMethods(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServicePaginatedResultOfPossibleVrfMethodDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServicePaginatedResultOfPossibleVrfMethodDTO>;
        }));
    }

    protected processGetPossibleVerificationMethods(response: HttpResponseBase): Observable<ServicePaginatedResultOfPossibleVrfMethodDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServicePaginatedResultOfPossibleVrfMethodDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addVerificationMethod(request: AddVerificationMethodRequest): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/VerificationMethods/AddVerificationMethod";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddVerificationMethod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddVerificationMethod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processAddVerificationMethod(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addAliases(aliases: string[] | null | undefined, verificationMethodId: string | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/VerificationMethods/AddAliases";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (aliases !== null && aliases !== undefined)
            aliases.forEach(item_ => content_.append("Aliases", item_.toString()));
        if (verificationMethodId === null || verificationMethodId === undefined)
            throw new Error("The parameter 'verificationMethodId' cannot be null.");
        else
            content_.append("VerificationMethodId", verificationMethodId.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAliases(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAliases(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processAddAliases(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteVerificationMethod(verificationMethodId: string | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/VerificationMethods/DeleteVerificationMethod?";
        if (verificationMethodId === null)
            throw new Error("The parameter 'verificationMethodId' cannot be null.");
        else if (verificationMethodId !== undefined)
            url_ += "verificationMethodId=" + encodeURIComponent("" + verificationMethodId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVerificationMethod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVerificationMethod(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processDeleteVerificationMethod(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    downloadFile(fileId: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/VerificationMethods/DownloadFile?";
        if (fileId === null)
            throw new Error("The parameter 'fileId' cannot be null.");
        else if (fileId !== undefined)
            url_ += "fileId=" + encodeURIComponent("" + fileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadFile(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class VerificationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getInitialVerifications(pageIndex: number | undefined, pageSize: number | undefined, deviceTypeNumber: string | null | undefined, yearMonth: string | null | undefined, typeInfo: string | null | undefined, location: DeviceLocation | null | undefined): Observable<ServicePaginatedResultOfSuccessInitialVerificationDto> {
        let url_ = this.baseUrl + "/api/Verifications/GetInitialVerifications?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (deviceTypeNumber !== undefined && deviceTypeNumber !== null)
            url_ += "DeviceTypeNumber=" + encodeURIComponent("" + deviceTypeNumber) + "&";
        if (yearMonth !== undefined && yearMonth !== null)
            url_ += "YearMonth=" + encodeURIComponent("" + yearMonth) + "&";
        if (typeInfo !== undefined && typeInfo !== null)
            url_ += "TypeInfo=" + encodeURIComponent("" + typeInfo) + "&";
        if (location !== undefined && location !== null)
            url_ += "Location=" + encodeURIComponent("" + location) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInitialVerifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInitialVerifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServicePaginatedResultOfSuccessInitialVerificationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServicePaginatedResultOfSuccessInitialVerificationDto>;
        }));
    }

    protected processGetInitialVerifications(response: HttpResponseBase): Observable<ServicePaginatedResultOfSuccessInitialVerificationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServicePaginatedResultOfSuccessInitialVerificationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setValues(excelFile: FileParameter | null | undefined, sheetName: string | null | undefined, dataRange: string | null | undefined, location: string | null | undefined, group: string | null | undefined, verificationTypeNum: boolean | null | undefined, worker: boolean | null | undefined, pressure: boolean | null | undefined, temperature: boolean | null | undefined, humidity: boolean | null | undefined, measurementRange: boolean | null | undefined, accuracy: boolean | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/Verifications/SetValues";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (excelFile !== null && excelFile !== undefined)
            content_.append("excelFile", excelFile.data, excelFile.fileName ? excelFile.fileName : "excelFile");
        if (sheetName !== null && sheetName !== undefined)
            content_.append("SheetName", sheetName.toString());
        if (dataRange !== null && dataRange !== undefined)
            content_.append("DataRange", dataRange.toString());
        if (location !== null && location !== undefined)
            content_.append("Location", location.toString());
        if (group !== null && group !== undefined)
            content_.append("Group", group.toString());
        if (verificationTypeNum !== null && verificationTypeNum !== undefined)
            content_.append("VerificationTypeNum", verificationTypeNum.toString());
        if (worker !== null && worker !== undefined)
            content_.append("Worker", worker.toString());
        if (pressure !== null && pressure !== undefined)
            content_.append("Pressure", pressure.toString());
        if (temperature !== null && temperature !== undefined)
            content_.append("Temperature", temperature.toString());
        if (humidity !== null && humidity !== undefined)
            content_.append("Humidity", humidity.toString());
        if (measurementRange !== null && measurementRange !== undefined)
            content_.append("MeasurementRange", measurementRange.toString());
        if (accuracy !== null && accuracy !== undefined)
            content_.append("Accuracy", accuracy.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processSetValues(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setVerificationNum(sheetName: string | undefined, excelFile: FileParameter | null | undefined, dataRange: string | null | undefined): Observable<ServiceResult> {
        let url_ = this.baseUrl + "/api/Verifications/SetVerificationNum?";
        if (sheetName === null)
            throw new Error("The parameter 'sheetName' cannot be null.");
        else if (sheetName !== undefined)
            url_ += "sheetName=" + encodeURIComponent("" + sheetName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (excelFile !== null && excelFile !== undefined)
            content_.append("excelFile", excelFile.data, excelFile.fileName ? excelFile.fileName : "excelFile");
        if (dataRange !== null && dataRange !== undefined)
            content_.append("dataRange", dataRange.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetVerificationNum(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetVerificationNum(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ServiceResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ServiceResult>;
        }));
    }

    protected processSetVerificationNum(response: HttpResponseBase): Observable<ServiceResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ServicePaginatedResultOfDavlenie1VerificationDTO implements IServicePaginatedResultOfDavlenie1VerificationDTO {
    message?: string | undefined;
    error?: string | undefined;
    data?: PaginatedListOfDavlenie1VerificationDTO | undefined;

    constructor(data?: IServicePaginatedResultOfDavlenie1VerificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.error = _data["error"];
            this.data = _data["data"] ? PaginatedListOfDavlenie1VerificationDTO.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServicePaginatedResultOfDavlenie1VerificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePaginatedResultOfDavlenie1VerificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["error"] = this.error;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IServicePaginatedResultOfDavlenie1VerificationDTO {
    message?: string | undefined;
    error?: string | undefined;
    data?: PaginatedListOfDavlenie1VerificationDTO | undefined;
}

export class PaginatedListOfDavlenie1VerificationDTO implements IPaginatedListOfDavlenie1VerificationDTO {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: Davlenie1VerificationDTO[];

    constructor(data?: IPaginatedListOfDavlenie1VerificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Davlenie1VerificationDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListOfDavlenie1VerificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfDavlenie1VerificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IPaginatedListOfDavlenie1VerificationDTO {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: Davlenie1VerificationDTO[];
}

export class Davlenie1VerificationDTO implements IDavlenie1VerificationDTO {
    id?: string;
    protocolNumber?: string;
    deviceTypeName?: string;
    deviceModification?: string;
    deviceTypeNumber?: string;
    deviceSerial?: string;
    manufactureYear?: number;
    owner?: string;
    ownerINN?: number;
    verificationsInfo?: string;
    etalonsInfo?: string;
    temperature?: number;
    humidity?: number;
    pressure?: string;
    verificationDate?: Date;
    worker?: string;
    verificationGroup?: VerificationGroup;
    location?: DeviceLocation;
    verifiedUntilDate?: Date;
    measurementMin?: number;
    measurementMax?: number;
    measurementUnit?: string;
    pressureInputs?: number[];
    etalonValues?: number[];
    deviceValues?: number[][];
    actualError?: number[][];
    validError?: number;
    variations?: number[];

    constructor(data?: IDavlenie1VerificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.protocolNumber = _data["protocolNumber"];
            this.deviceTypeName = _data["deviceTypeName"];
            this.deviceModification = _data["deviceModification"];
            this.deviceTypeNumber = _data["deviceTypeNumber"];
            this.deviceSerial = _data["deviceSerial"];
            this.manufactureYear = _data["manufactureYear"];
            this.owner = _data["owner"];
            this.ownerINN = _data["ownerINN"];
            this.verificationsInfo = _data["verificationsInfo"];
            this.etalonsInfo = _data["etalonsInfo"];
            this.temperature = _data["temperature"];
            this.humidity = _data["humidity"];
            this.pressure = _data["pressure"];
            this.verificationDate = _data["verificationDate"] ? new Date(_data["verificationDate"].toString()) : <any>undefined;
            this.worker = _data["worker"];
            this.verificationGroup = _data["verificationGroup"];
            this.location = _data["location"];
            this.verifiedUntilDate = _data["verifiedUntilDate"] ? new Date(_data["verifiedUntilDate"].toString()) : <any>undefined;
            this.measurementMin = _data["measurementMin"];
            this.measurementMax = _data["measurementMax"];
            this.measurementUnit = _data["measurementUnit"];
            if (Array.isArray(_data["pressureInputs"])) {
                this.pressureInputs = [] as any;
                for (let item of _data["pressureInputs"])
                    this.pressureInputs!.push(item);
            }
            if (Array.isArray(_data["etalonValues"])) {
                this.etalonValues = [] as any;
                for (let item of _data["etalonValues"])
                    this.etalonValues!.push(item);
            }
            if (Array.isArray(_data["deviceValues"])) {
                this.deviceValues = [] as any;
                for (let item of _data["deviceValues"])
                    this.deviceValues!.push(item);
            }
            if (Array.isArray(_data["actualError"])) {
                this.actualError = [] as any;
                for (let item of _data["actualError"])
                    this.actualError!.push(item);
            }
            this.validError = _data["validError"];
            if (Array.isArray(_data["variations"])) {
                this.variations = [] as any;
                for (let item of _data["variations"])
                    this.variations!.push(item);
            }
        }
    }

    static fromJS(data: any): Davlenie1VerificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new Davlenie1VerificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["protocolNumber"] = this.protocolNumber;
        data["deviceTypeName"] = this.deviceTypeName;
        data["deviceModification"] = this.deviceModification;
        data["deviceTypeNumber"] = this.deviceTypeNumber;
        data["deviceSerial"] = this.deviceSerial;
        data["manufactureYear"] = this.manufactureYear;
        data["owner"] = this.owner;
        data["ownerINN"] = this.ownerINN;
        data["verificationsInfo"] = this.verificationsInfo;
        data["etalonsInfo"] = this.etalonsInfo;
        data["temperature"] = this.temperature;
        data["humidity"] = this.humidity;
        data["pressure"] = this.pressure;
        data["verificationDate"] = this.verificationDate ? formatDate(this.verificationDate) : <any>undefined;
        data["worker"] = this.worker;
        data["verificationGroup"] = this.verificationGroup;
        data["location"] = this.location;
        data["verifiedUntilDate"] = this.verifiedUntilDate ? formatDate(this.verifiedUntilDate) : <any>undefined;
        data["measurementMin"] = this.measurementMin;
        data["measurementMax"] = this.measurementMax;
        data["measurementUnit"] = this.measurementUnit;
        if (Array.isArray(this.pressureInputs)) {
            data["pressureInputs"] = [];
            for (let item of this.pressureInputs)
                data["pressureInputs"].push(item);
        }
        if (Array.isArray(this.etalonValues)) {
            data["etalonValues"] = [];
            for (let item of this.etalonValues)
                data["etalonValues"].push(item);
        }
        if (Array.isArray(this.deviceValues)) {
            data["deviceValues"] = [];
            for (let item of this.deviceValues)
                data["deviceValues"].push(item);
        }
        if (Array.isArray(this.actualError)) {
            data["actualError"] = [];
            for (let item of this.actualError)
                data["actualError"].push(item);
        }
        data["validError"] = this.validError;
        if (Array.isArray(this.variations)) {
            data["variations"] = [];
            for (let item of this.variations)
                data["variations"].push(item);
        }
        return data;
    }
}

export interface IDavlenie1VerificationDTO {
    id?: string;
    protocolNumber?: string;
    deviceTypeName?: string;
    deviceModification?: string;
    deviceTypeNumber?: string;
    deviceSerial?: string;
    manufactureYear?: number;
    owner?: string;
    ownerINN?: number;
    verificationsInfo?: string;
    etalonsInfo?: string;
    temperature?: number;
    humidity?: number;
    pressure?: string;
    verificationDate?: Date;
    worker?: string;
    verificationGroup?: VerificationGroup;
    location?: DeviceLocation;
    verifiedUntilDate?: Date;
    measurementMin?: number;
    measurementMax?: number;
    measurementUnit?: string;
    pressureInputs?: number[];
    etalonValues?: number[];
    deviceValues?: number[][];
    actualError?: number[][];
    validError?: number;
    variations?: number[];
}

export enum VerificationGroup {
    Манометры = "Манометры",
    Датчики_давления = "Датчики_давления",
    Термометры_биметаллические = "Термометры_биметаллические",
}

export enum DeviceLocation {
    АнтипинскийНПЗ = "АнтипинскийНПЗ",
    ГПНЯмал = "ГПНЯмал",
}

export class ServiceResult implements IServiceResult {
    message?: string | undefined;
    error?: string | undefined;

    constructor(data?: IServiceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ServiceResult {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["error"] = this.error;
        return data;
    }
}

export interface IServiceResult {
    message?: string | undefined;
    error?: string | undefined;
}

export class ServicePaginatedResultOfDeviceType implements IServicePaginatedResultOfDeviceType {
    message?: string | undefined;
    error?: string | undefined;
    data?: PaginatedListOfDeviceType | undefined;

    constructor(data?: IServicePaginatedResultOfDeviceType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.error = _data["error"];
            this.data = _data["data"] ? PaginatedListOfDeviceType.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServicePaginatedResultOfDeviceType {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePaginatedResultOfDeviceType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["error"] = this.error;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IServicePaginatedResultOfDeviceType {
    message?: string | undefined;
    error?: string | undefined;
    data?: PaginatedListOfDeviceType | undefined;
}

export class PaginatedListOfDeviceType implements IPaginatedListOfDeviceType {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: DeviceType[];

    constructor(data?: IPaginatedListOfDeviceType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListOfDeviceType {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfDeviceType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IPaginatedListOfDeviceType {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: DeviceType[];
}

export abstract class DatabaseEntity implements IDatabaseEntity {
    id?: string;

    constructor(data?: IDatabaseEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DatabaseEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'DatabaseEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IDatabaseEntity {
    id?: string;
}

export class DeviceType extends DatabaseEntity implements IDeviceType {
    number?: string;
    title?: string;
    notation?: string;
    methodUrls?: string[] | undefined;
    specUrls?: string[] | undefined;
    manufacturers?: string[] | undefined;

    constructor(data?: IDeviceType) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.number = _data["number"];
            this.title = _data["title"];
            this.notation = _data["notation"];
            if (Array.isArray(_data["methodUrls"])) {
                this.methodUrls = [] as any;
                for (let item of _data["methodUrls"])
                    this.methodUrls!.push(item);
            }
            if (Array.isArray(_data["specUrls"])) {
                this.specUrls = [] as any;
                for (let item of _data["specUrls"])
                    this.specUrls!.push(item);
            }
            if (Array.isArray(_data["manufacturers"])) {
                this.manufacturers = [] as any;
                for (let item of _data["manufacturers"])
                    this.manufacturers!.push(item);
            }
        }
    }

    static override fromJS(data: any): DeviceType {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceType();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["title"] = this.title;
        data["notation"] = this.notation;
        if (Array.isArray(this.methodUrls)) {
            data["methodUrls"] = [];
            for (let item of this.methodUrls)
                data["methodUrls"].push(item);
        }
        if (Array.isArray(this.specUrls)) {
            data["specUrls"] = [];
            for (let item of this.specUrls)
                data["specUrls"].push(item);
        }
        if (Array.isArray(this.manufacturers)) {
            data["manufacturers"] = [];
            for (let item of this.manufacturers)
                data["manufacturers"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IDeviceType extends IDatabaseEntity {
    number?: string;
    title?: string;
    notation?: string;
    methodUrls?: string[] | undefined;
    specUrls?: string[] | undefined;
    manufacturers?: string[] | undefined;
}

export class ExportToPdfRequest implements IExportToPdfRequest {
    group?: VerificationGroup;
    ids?: string[];

    constructor(data?: IExportToPdfRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data["group"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): ExportToPdfRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ExportToPdfRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }
}

export interface IExportToPdfRequest {
    group?: VerificationGroup;
    ids?: string[];
}

export class ServicePaginatedResultOfInitialVerificationJob implements IServicePaginatedResultOfInitialVerificationJob {
    message?: string | undefined;
    error?: string | undefined;
    data?: PaginatedListOfInitialVerificationJob | undefined;

    constructor(data?: IServicePaginatedResultOfInitialVerificationJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.error = _data["error"];
            this.data = _data["data"] ? PaginatedListOfInitialVerificationJob.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServicePaginatedResultOfInitialVerificationJob {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePaginatedResultOfInitialVerificationJob();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["error"] = this.error;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IServicePaginatedResultOfInitialVerificationJob {
    message?: string | undefined;
    error?: string | undefined;
    data?: PaginatedListOfInitialVerificationJob | undefined;
}

export class PaginatedListOfInitialVerificationJob implements IPaginatedListOfInitialVerificationJob {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: InitialVerificationJob[];

    constructor(data?: IPaginatedListOfInitialVerificationJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InitialVerificationJob.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListOfInitialVerificationJob {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfInitialVerificationJob();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IPaginatedListOfInitialVerificationJob {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: InitialVerificationJob[];
}

export class InitialVerificationJob extends DatabaseEntity implements IInitialVerificationJob {
    date?: YearMonth;

    constructor(data?: IInitialVerificationJob) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.date = _data["date"] ? YearMonth.fromJS(_data["date"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): InitialVerificationJob {
        data = typeof data === 'object' ? data : {};
        let result = new InitialVerificationJob();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IInitialVerificationJob extends IDatabaseEntity {
    date?: YearMonth;
}

export class YearMonth implements IYearMonth {
    year?: number;
    month?: number;

    constructor(data?: IYearMonth) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
            this.month = _data["month"];
        }
    }

    static fromJS(data: any): YearMonth {
        data = typeof data === 'object' ? data : {};
        let result = new YearMonth();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["month"] = this.month;
        return data;
    }
}

export interface IYearMonth {
    year?: number;
    month?: number;
}

export class ServicePaginatedResultOfManometr1VerificationDto implements IServicePaginatedResultOfManometr1VerificationDto {
    message?: string | undefined;
    error?: string | undefined;
    data?: PaginatedListOfManometr1VerificationDto | undefined;

    constructor(data?: IServicePaginatedResultOfManometr1VerificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.error = _data["error"];
            this.data = _data["data"] ? PaginatedListOfManometr1VerificationDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServicePaginatedResultOfManometr1VerificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePaginatedResultOfManometr1VerificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["error"] = this.error;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IServicePaginatedResultOfManometr1VerificationDto {
    message?: string | undefined;
    error?: string | undefined;
    data?: PaginatedListOfManometr1VerificationDto | undefined;
}

export class PaginatedListOfManometr1VerificationDto implements IPaginatedListOfManometr1VerificationDto {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: Manometr1VerificationDto[];

    constructor(data?: IPaginatedListOfManometr1VerificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Manometr1VerificationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListOfManometr1VerificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfManometr1VerificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IPaginatedListOfManometr1VerificationDto {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: Manometr1VerificationDto[];
}

export class Manometr1VerificationDto implements IManometr1VerificationDto {
    id?: string;
    protocolNumber?: string;
    deviceTypeName?: string;
    deviceModification?: string;
    deviceTypeNumber?: string;
    deviceSerial?: string;
    manufactureYear?: number;
    owner?: string;
    ownerINN?: number;
    verificationsInfo?: string;
    etalonsInfo?: string;
    temperature?: number;
    humidity?: number;
    pressure?: string;
    verificationDate?: Date;
    worker?: string;
    verificationGroup?: VerificationGroup;
    location?: DeviceLocation;
    verifiedUntilDate?: Date;
    measurementMin?: number;
    measurementMax?: number;
    measurementUnit?: string;
    validError?: number;
    deviceValues?: number[][];
    etalonValues?: number[][];
    actualError?: number[][];
    actualVariation?: number[];

    constructor(data?: IManometr1VerificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.protocolNumber = _data["protocolNumber"];
            this.deviceTypeName = _data["deviceTypeName"];
            this.deviceModification = _data["deviceModification"];
            this.deviceTypeNumber = _data["deviceTypeNumber"];
            this.deviceSerial = _data["deviceSerial"];
            this.manufactureYear = _data["manufactureYear"];
            this.owner = _data["owner"];
            this.ownerINN = _data["ownerINN"];
            this.verificationsInfo = _data["verificationsInfo"];
            this.etalonsInfo = _data["etalonsInfo"];
            this.temperature = _data["temperature"];
            this.humidity = _data["humidity"];
            this.pressure = _data["pressure"];
            this.verificationDate = _data["verificationDate"] ? new Date(_data["verificationDate"].toString()) : <any>undefined;
            this.worker = _data["worker"];
            this.verificationGroup = _data["verificationGroup"];
            this.location = _data["location"];
            this.verifiedUntilDate = _data["verifiedUntilDate"] ? new Date(_data["verifiedUntilDate"].toString()) : <any>undefined;
            this.measurementMin = _data["measurementMin"];
            this.measurementMax = _data["measurementMax"];
            this.measurementUnit = _data["measurementUnit"];
            this.validError = _data["validError"];
            if (Array.isArray(_data["deviceValues"])) {
                this.deviceValues = [] as any;
                for (let item of _data["deviceValues"])
                    this.deviceValues!.push(item);
            }
            if (Array.isArray(_data["etalonValues"])) {
                this.etalonValues = [] as any;
                for (let item of _data["etalonValues"])
                    this.etalonValues!.push(item);
            }
            if (Array.isArray(_data["actualError"])) {
                this.actualError = [] as any;
                for (let item of _data["actualError"])
                    this.actualError!.push(item);
            }
            if (Array.isArray(_data["actualVariation"])) {
                this.actualVariation = [] as any;
                for (let item of _data["actualVariation"])
                    this.actualVariation!.push(item);
            }
        }
    }

    static fromJS(data: any): Manometr1VerificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new Manometr1VerificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["protocolNumber"] = this.protocolNumber;
        data["deviceTypeName"] = this.deviceTypeName;
        data["deviceModification"] = this.deviceModification;
        data["deviceTypeNumber"] = this.deviceTypeNumber;
        data["deviceSerial"] = this.deviceSerial;
        data["manufactureYear"] = this.manufactureYear;
        data["owner"] = this.owner;
        data["ownerINN"] = this.ownerINN;
        data["verificationsInfo"] = this.verificationsInfo;
        data["etalonsInfo"] = this.etalonsInfo;
        data["temperature"] = this.temperature;
        data["humidity"] = this.humidity;
        data["pressure"] = this.pressure;
        data["verificationDate"] = this.verificationDate ? formatDate(this.verificationDate) : <any>undefined;
        data["worker"] = this.worker;
        data["verificationGroup"] = this.verificationGroup;
        data["location"] = this.location;
        data["verifiedUntilDate"] = this.verifiedUntilDate ? formatDate(this.verifiedUntilDate) : <any>undefined;
        data["measurementMin"] = this.measurementMin;
        data["measurementMax"] = this.measurementMax;
        data["measurementUnit"] = this.measurementUnit;
        data["validError"] = this.validError;
        if (Array.isArray(this.deviceValues)) {
            data["deviceValues"] = [];
            for (let item of this.deviceValues)
                data["deviceValues"].push(item);
        }
        if (Array.isArray(this.etalonValues)) {
            data["etalonValues"] = [];
            for (let item of this.etalonValues)
                data["etalonValues"].push(item);
        }
        if (Array.isArray(this.actualError)) {
            data["actualError"] = [];
            for (let item of this.actualError)
                data["actualError"].push(item);
        }
        if (Array.isArray(this.actualVariation)) {
            data["actualVariation"] = [];
            for (let item of this.actualVariation)
                data["actualVariation"].push(item);
        }
        return data;
    }
}

export interface IManometr1VerificationDto {
    id?: string;
    protocolNumber?: string;
    deviceTypeName?: string;
    deviceModification?: string;
    deviceTypeNumber?: string;
    deviceSerial?: string;
    manufactureYear?: number;
    owner?: string;
    ownerINN?: number;
    verificationsInfo?: string;
    etalonsInfo?: string;
    temperature?: number;
    humidity?: number;
    pressure?: string;
    verificationDate?: Date;
    worker?: string;
    verificationGroup?: VerificationGroup;
    location?: DeviceLocation;
    verifiedUntilDate?: Date;
    measurementMin?: number;
    measurementMax?: number;
    measurementUnit?: string;
    validError?: number;
    deviceValues?: number[][];
    etalonValues?: number[][];
    actualError?: number[][];
    actualVariation?: number[];
}

export class ServicePaginatedResultOfOwner implements IServicePaginatedResultOfOwner {
    message?: string | undefined;
    error?: string | undefined;
    data?: PaginatedListOfOwner | undefined;

    constructor(data?: IServicePaginatedResultOfOwner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.error = _data["error"];
            this.data = _data["data"] ? PaginatedListOfOwner.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServicePaginatedResultOfOwner {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePaginatedResultOfOwner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["error"] = this.error;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IServicePaginatedResultOfOwner {
    message?: string | undefined;
    error?: string | undefined;
    data?: PaginatedListOfOwner | undefined;
}

export class PaginatedListOfOwner implements IPaginatedListOfOwner {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: Owner[];

    constructor(data?: IPaginatedListOfOwner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Owner.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListOfOwner {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfOwner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IPaginatedListOfOwner {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: Owner[];
}

export class Owner extends DatabaseEntity implements IOwner {
    name?: string;
    inn?: number;

    constructor(data?: IOwner) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.inn = _data["inn"];
        }
    }

    static override fromJS(data: any): Owner {
        data = typeof data === 'object' ? data : {};
        let result = new Owner();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["inn"] = this.inn;
        super.toJSON(data);
        return data;
    }
}

export interface IOwner extends IDatabaseEntity {
    name?: string;
    inn?: number;
}

export class ServicePaginatedResultOfProtocolTemplateDTO implements IServicePaginatedResultOfProtocolTemplateDTO {
    message?: string | undefined;
    error?: string | undefined;
    data?: PaginatedListOfProtocolTemplateDTO | undefined;

    constructor(data?: IServicePaginatedResultOfProtocolTemplateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.error = _data["error"];
            this.data = _data["data"] ? PaginatedListOfProtocolTemplateDTO.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServicePaginatedResultOfProtocolTemplateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePaginatedResultOfProtocolTemplateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["error"] = this.error;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IServicePaginatedResultOfProtocolTemplateDTO {
    message?: string | undefined;
    error?: string | undefined;
    data?: PaginatedListOfProtocolTemplateDTO | undefined;
}

export class PaginatedListOfProtocolTemplateDTO implements IPaginatedListOfProtocolTemplateDTO {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: ProtocolTemplateDTO[];

    constructor(data?: IPaginatedListOfProtocolTemplateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProtocolTemplateDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListOfProtocolTemplateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProtocolTemplateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IPaginatedListOfProtocolTemplateDTO {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: ProtocolTemplateDTO[];
}

export class ProtocolTemplateDTO implements IProtocolTemplateDTO {
    id?: string;
    protocolGroup?: ProtocolGroup;
    verificationGroup?: VerificationGroup;
    verificationMethodsAliases?: string[];

    constructor(data?: IProtocolTemplateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.protocolGroup = _data["protocolGroup"];
            this.verificationGroup = _data["verificationGroup"];
            if (Array.isArray(_data["verificationMethodsAliases"])) {
                this.verificationMethodsAliases = [] as any;
                for (let item of _data["verificationMethodsAliases"])
                    this.verificationMethodsAliases!.push(item);
            }
        }
    }

    static fromJS(data: any): ProtocolTemplateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProtocolTemplateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["protocolGroup"] = this.protocolGroup;
        data["verificationGroup"] = this.verificationGroup;
        if (Array.isArray(this.verificationMethodsAliases)) {
            data["verificationMethodsAliases"] = [];
            for (let item of this.verificationMethodsAliases)
                data["verificationMethodsAliases"].push(item);
        }
        return data;
    }
}

export interface IProtocolTemplateDTO {
    id?: string;
    protocolGroup?: ProtocolGroup;
    verificationGroup?: VerificationGroup;
    verificationMethodsAliases?: string[];
}

export enum ProtocolGroup {
    Манометр1 = "Манометр1",
    Давление1 = "Давление1",
}

export class ServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO implements IServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO {
    message?: string | undefined;
    error?: string | undefined;
    data?: PaginatedListOfPossibleTemplateVerificationMethodsDTO | undefined;

    constructor(data?: IServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.error = _data["error"];
            this.data = _data["data"] ? PaginatedListOfPossibleTemplateVerificationMethodsDTO.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["error"] = this.error;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IServicePaginatedResultOfPossibleTemplateVerificationMethodsDTO {
    message?: string | undefined;
    error?: string | undefined;
    data?: PaginatedListOfPossibleTemplateVerificationMethodsDTO | undefined;
}

export class PaginatedListOfPossibleTemplateVerificationMethodsDTO implements IPaginatedListOfPossibleTemplateVerificationMethodsDTO {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: PossibleTemplateVerificationMethodsDTO[];

    constructor(data?: IPaginatedListOfPossibleTemplateVerificationMethodsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PossibleTemplateVerificationMethodsDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListOfPossibleTemplateVerificationMethodsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfPossibleTemplateVerificationMethodsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IPaginatedListOfPossibleTemplateVerificationMethodsDTO {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: PossibleTemplateVerificationMethodsDTO[];
}

export class PossibleTemplateVerificationMethodsDTO implements IPossibleTemplateVerificationMethodsDTO {
    protocolId?: string;
    verificationMethod?: VerificationMethod;

    constructor(data?: IPossibleTemplateVerificationMethodsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.protocolId = _data["protocolId"];
            this.verificationMethod = _data["verificationMethod"] ? VerificationMethod.fromJS(_data["verificationMethod"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PossibleTemplateVerificationMethodsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PossibleTemplateVerificationMethodsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["protocolId"] = this.protocolId;
        data["verificationMethod"] = this.verificationMethod ? this.verificationMethod.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPossibleTemplateVerificationMethodsDTO {
    protocolId?: string;
    verificationMethod?: VerificationMethod;
}

export class VerificationMethod extends DatabaseEntity implements IVerificationMethod {
    aliases?: string[];
    description?: string;
    checkups?: { [key: string]: string; };
    protocolTemplateId?: string | undefined;
    protocolTemplate?: ProtocolTemplate | undefined;
    verificationMethodFiles?: VerificationMethodFile[] | undefined;
    successInitialVerifications?: SuccessInitialVerification[] | undefined;
    failedInitialVerifications?: FailedInitialVerification[] | undefined;
    manometr1Verifications?: Manometr1Verification[] | undefined;
    davlenie1Verifications?: Davlenie1Verification[] | undefined;

    constructor(data?: IVerificationMethod) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["aliases"])) {
                this.aliases = [] as any;
                for (let item of _data["aliases"])
                    this.aliases!.push(item);
            }
            this.description = _data["description"];
            if (_data["checkups"]) {
                this.checkups = {} as any;
                for (let key in _data["checkups"]) {
                    if (_data["checkups"].hasOwnProperty(key))
                        (<any>this.checkups)![key] = _data["checkups"][key];
                }
            }
            this.protocolTemplateId = _data["protocolTemplateId"];
            this.protocolTemplate = _data["protocolTemplate"] ? ProtocolTemplate.fromJS(_data["protocolTemplate"]) : <any>undefined;
            if (Array.isArray(_data["verificationMethodFiles"])) {
                this.verificationMethodFiles = [] as any;
                for (let item of _data["verificationMethodFiles"])
                    this.verificationMethodFiles!.push(VerificationMethodFile.fromJS(item));
            }
            if (Array.isArray(_data["successInitialVerifications"])) {
                this.successInitialVerifications = [] as any;
                for (let item of _data["successInitialVerifications"])
                    this.successInitialVerifications!.push(SuccessInitialVerification.fromJS(item));
            }
            if (Array.isArray(_data["failedInitialVerifications"])) {
                this.failedInitialVerifications = [] as any;
                for (let item of _data["failedInitialVerifications"])
                    this.failedInitialVerifications!.push(FailedInitialVerification.fromJS(item));
            }
            if (Array.isArray(_data["manometr1Verifications"])) {
                this.manometr1Verifications = [] as any;
                for (let item of _data["manometr1Verifications"])
                    this.manometr1Verifications!.push(Manometr1Verification.fromJS(item));
            }
            if (Array.isArray(_data["davlenie1Verifications"])) {
                this.davlenie1Verifications = [] as any;
                for (let item of _data["davlenie1Verifications"])
                    this.davlenie1Verifications!.push(Davlenie1Verification.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): VerificationMethod {
        data = typeof data === 'object' ? data : {};
        let result = new VerificationMethod();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.aliases)) {
            data["aliases"] = [];
            for (let item of this.aliases)
                data["aliases"].push(item);
        }
        data["description"] = this.description;
        if (this.checkups) {
            data["checkups"] = {};
            for (let key in this.checkups) {
                if (this.checkups.hasOwnProperty(key))
                    (<any>data["checkups"])[key] = (<any>this.checkups)[key];
            }
        }
        data["protocolTemplateId"] = this.protocolTemplateId;
        data["protocolTemplate"] = this.protocolTemplate ? this.protocolTemplate.toJSON() : <any>undefined;
        if (Array.isArray(this.verificationMethodFiles)) {
            data["verificationMethodFiles"] = [];
            for (let item of this.verificationMethodFiles)
                data["verificationMethodFiles"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.successInitialVerifications)) {
            data["successInitialVerifications"] = [];
            for (let item of this.successInitialVerifications)
                data["successInitialVerifications"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.failedInitialVerifications)) {
            data["failedInitialVerifications"] = [];
            for (let item of this.failedInitialVerifications)
                data["failedInitialVerifications"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.manometr1Verifications)) {
            data["manometr1Verifications"] = [];
            for (let item of this.manometr1Verifications)
                data["manometr1Verifications"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.davlenie1Verifications)) {
            data["davlenie1Verifications"] = [];
            for (let item of this.davlenie1Verifications)
                data["davlenie1Verifications"].push(item ? item.toJSON() : <any>undefined);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IVerificationMethod extends IDatabaseEntity {
    aliases?: string[];
    description?: string;
    checkups?: { [key: string]: string; };
    protocolTemplateId?: string | undefined;
    protocolTemplate?: ProtocolTemplate | undefined;
    verificationMethodFiles?: VerificationMethodFile[] | undefined;
    successInitialVerifications?: SuccessInitialVerification[] | undefined;
    failedInitialVerifications?: FailedInitialVerification[] | undefined;
    manometr1Verifications?: Manometr1Verification[] | undefined;
    davlenie1Verifications?: Davlenie1Verification[] | undefined;
}

export class ProtocolTemplate extends DatabaseEntity implements IProtocolTemplate {
    verificationGroup?: VerificationGroup;
    protocolGroup?: ProtocolGroup;
    verificationMethods?: VerificationMethod[] | undefined;

    constructor(data?: IProtocolTemplate) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.verificationGroup = _data["verificationGroup"];
            this.protocolGroup = _data["protocolGroup"];
            if (Array.isArray(_data["verificationMethods"])) {
                this.verificationMethods = [] as any;
                for (let item of _data["verificationMethods"])
                    this.verificationMethods!.push(VerificationMethod.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ProtocolTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new ProtocolTemplate();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["verificationGroup"] = this.verificationGroup;
        data["protocolGroup"] = this.protocolGroup;
        if (Array.isArray(this.verificationMethods)) {
            data["verificationMethods"] = [];
            for (let item of this.verificationMethods)
                data["verificationMethods"].push(item ? item.toJSON() : <any>undefined);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IProtocolTemplate extends IDatabaseEntity {
    verificationGroup?: VerificationGroup;
    protocolGroup?: ProtocolGroup;
    verificationMethods?: VerificationMethod[] | undefined;
}

export class VerificationMethodFile extends DatabaseEntity implements IVerificationMethodFile {
    fileName?: string;
    mimetype?: string;
    content?: string;

    constructor(data?: IVerificationMethodFile) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fileName = _data["fileName"];
            this.mimetype = _data["mimetype"];
            this.content = _data["content"];
        }
    }

    static override fromJS(data: any): VerificationMethodFile {
        data = typeof data === 'object' ? data : {};
        let result = new VerificationMethodFile();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["mimetype"] = this.mimetype;
        data["content"] = this.content;
        super.toJSON(data);
        return data;
    }
}

export interface IVerificationMethodFile extends IDatabaseEntity {
    fileName?: string;
    mimetype?: string;
    content?: string;
}

export class SuccessInitialVerification extends DatabaseEntity implements ISuccessInitialVerification {
    deviceTypeNumber?: string;
    deviceSerial?: string;
    owner?: string;
    verificationTypeName?: string;
    verificationDate?: Date;
    verifiedUntilDate?: Date;
    verificationGroup?: VerificationGroup | undefined;
    protocolNumber?: string | undefined;
    ownerINN?: number | undefined;
    worker?: string | undefined;
    location?: DeviceLocation | undefined;
    pressure?: string | undefined;
    temperature?: number | undefined;
    humidity?: number | undefined;
    measurementMin?: number | undefined;
    measurementMax?: number | undefined;
    measurementUnit?: string | undefined;
    accuracy?: number | undefined;
    device?: Device | undefined;
    verificationMethod?: VerificationMethod | undefined;
    etalons?: Etalon[] | undefined;

    constructor(data?: ISuccessInitialVerification) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.deviceTypeNumber = _data["deviceTypeNumber"];
            this.deviceSerial = _data["deviceSerial"];
            this.owner = _data["owner"];
            this.verificationTypeName = _data["verificationTypeName"];
            this.verificationDate = _data["verificationDate"] ? new Date(_data["verificationDate"].toString()) : <any>undefined;
            this.verifiedUntilDate = _data["verifiedUntilDate"] ? new Date(_data["verifiedUntilDate"].toString()) : <any>undefined;
            this.verificationGroup = _data["verificationGroup"];
            this.protocolNumber = _data["protocolNumber"];
            this.ownerINN = _data["ownerINN"];
            this.worker = _data["worker"];
            this.location = _data["location"];
            this.pressure = _data["pressure"];
            this.temperature = _data["temperature"];
            this.humidity = _data["humidity"];
            this.measurementMin = _data["measurementMin"];
            this.measurementMax = _data["measurementMax"];
            this.measurementUnit = _data["measurementUnit"];
            this.accuracy = _data["accuracy"];
            this.device = _data["device"] ? Device.fromJS(_data["device"]) : <any>undefined;
            this.verificationMethod = _data["verificationMethod"] ? VerificationMethod.fromJS(_data["verificationMethod"]) : <any>undefined;
            if (Array.isArray(_data["etalons"])) {
                this.etalons = [] as any;
                for (let item of _data["etalons"])
                    this.etalons!.push(Etalon.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): SuccessInitialVerification {
        data = typeof data === 'object' ? data : {};
        let result = new SuccessInitialVerification();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceTypeNumber"] = this.deviceTypeNumber;
        data["deviceSerial"] = this.deviceSerial;
        data["owner"] = this.owner;
        data["verificationTypeName"] = this.verificationTypeName;
        data["verificationDate"] = this.verificationDate ? formatDate(this.verificationDate) : <any>undefined;
        data["verifiedUntilDate"] = this.verifiedUntilDate ? formatDate(this.verifiedUntilDate) : <any>undefined;
        data["verificationGroup"] = this.verificationGroup;
        data["protocolNumber"] = this.protocolNumber;
        data["ownerINN"] = this.ownerINN;
        data["worker"] = this.worker;
        data["location"] = this.location;
        data["pressure"] = this.pressure;
        data["temperature"] = this.temperature;
        data["humidity"] = this.humidity;
        data["measurementMin"] = this.measurementMin;
        data["measurementMax"] = this.measurementMax;
        data["measurementUnit"] = this.measurementUnit;
        data["accuracy"] = this.accuracy;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["verificationMethod"] = this.verificationMethod ? this.verificationMethod.toJSON() : <any>undefined;
        if (Array.isArray(this.etalons)) {
            data["etalons"] = [];
            for (let item of this.etalons)
                data["etalons"].push(item ? item.toJSON() : <any>undefined);
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISuccessInitialVerification extends IDatabaseEntity {
    deviceTypeNumber?: string;
    deviceSerial?: string;
    owner?: string;
    verificationTypeName?: string;
    verificationDate?: Date;
    verifiedUntilDate?: Date;
    verificationGroup?: VerificationGroup | undefined;
    protocolNumber?: string | undefined;
    ownerINN?: number | undefined;
    worker?: string | undefined;
    location?: DeviceLocation | undefined;
    pressure?: string | undefined;
    temperature?: number | undefined;
    humidity?: number | undefined;
    measurementMin?: number | undefined;
    measurementMax?: number | undefined;
    measurementUnit?: string | undefined;
    accuracy?: number | undefined;
    device?: Device | undefined;
    verificationMethod?: VerificationMethod | undefined;
    etalons?: Etalon[] | undefined;
}

export class Device extends DatabaseEntity implements IDevice {
    deviceTypeNumber?: string;
    serial?: string;
    manufacturedYear?: number;
    modification?: string;
    deviceType?: DeviceType | undefined;

    constructor(data?: IDevice) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.deviceTypeNumber = _data["deviceTypeNumber"];
            this.serial = _data["serial"];
            this.manufacturedYear = _data["manufacturedYear"];
            this.modification = _data["modification"];
            this.deviceType = _data["deviceType"] ? DeviceType.fromJS(_data["deviceType"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Device {
        data = typeof data === 'object' ? data : {};
        let result = new Device();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceTypeNumber"] = this.deviceTypeNumber;
        data["serial"] = this.serial;
        data["manufacturedYear"] = this.manufacturedYear;
        data["modification"] = this.modification;
        data["deviceType"] = this.deviceType ? this.deviceType.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IDevice extends IDatabaseEntity {
    deviceTypeNumber?: string;
    serial?: string;
    manufacturedYear?: number;
    modification?: string;
    deviceType?: DeviceType | undefined;
}

export class Etalon extends DatabaseEntity implements IEtalon {
    number?: string;
    date?: Date;
    toDate?: Date;
    fullInfo?: string;
    successInitialVerifications?: SuccessInitialVerification[] | undefined;
    failedInitialVerifications?: FailedInitialVerification[] | undefined;
    manometr1Verifications?: Manometr1Verification[] | undefined;
    davlenie1Verifications?: Davlenie1Verification[] | undefined;

    constructor(data?: IEtalon) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.number = _data["number"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.fullInfo = _data["fullInfo"];
            if (Array.isArray(_data["successInitialVerifications"])) {
                this.successInitialVerifications = [] as any;
                for (let item of _data["successInitialVerifications"])
                    this.successInitialVerifications!.push(SuccessInitialVerification.fromJS(item));
            }
            if (Array.isArray(_data["failedInitialVerifications"])) {
                this.failedInitialVerifications = [] as any;
                for (let item of _data["failedInitialVerifications"])
                    this.failedInitialVerifications!.push(FailedInitialVerification.fromJS(item));
            }
            if (Array.isArray(_data["manometr1Verifications"])) {
                this.manometr1Verifications = [] as any;
                for (let item of _data["manometr1Verifications"])
                    this.manometr1Verifications!.push(Manometr1Verification.fromJS(item));
            }
            if (Array.isArray(_data["davlenie1Verifications"])) {
                this.davlenie1Verifications = [] as any;
                for (let item of _data["davlenie1Verifications"])
                    this.davlenie1Verifications!.push(Davlenie1Verification.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Etalon {
        data = typeof data === 'object' ? data : {};
        let result = new Etalon();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["toDate"] = this.toDate ? formatDate(this.toDate) : <any>undefined;
        data["fullInfo"] = this.fullInfo;
        if (Array.isArray(this.successInitialVerifications)) {
            data["successInitialVerifications"] = [];
            for (let item of this.successInitialVerifications)
                data["successInitialVerifications"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.failedInitialVerifications)) {
            data["failedInitialVerifications"] = [];
            for (let item of this.failedInitialVerifications)
                data["failedInitialVerifications"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.manometr1Verifications)) {
            data["manometr1Verifications"] = [];
            for (let item of this.manometr1Verifications)
                data["manometr1Verifications"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.davlenie1Verifications)) {
            data["davlenie1Verifications"] = [];
            for (let item of this.davlenie1Verifications)
                data["davlenie1Verifications"].push(item ? item.toJSON() : <any>undefined);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IEtalon extends IDatabaseEntity {
    number?: string;
    date?: Date;
    toDate?: Date;
    fullInfo?: string;
    successInitialVerifications?: SuccessInitialVerification[] | undefined;
    failedInitialVerifications?: FailedInitialVerification[] | undefined;
    manometr1Verifications?: Manometr1Verification[] | undefined;
    davlenie1Verifications?: Davlenie1Verification[] | undefined;
}

export class FailedInitialVerification extends DatabaseEntity implements IFailedInitialVerification {
    deviceTypeNumber?: string;
    deviceSerial?: string;
    owner?: string;
    verificationTypeName?: string;
    verificationDate?: Date;
    failedDocNumber?: string;
    verificationGroup?: VerificationGroup | undefined;
    protocolNumber?: string | undefined;
    ownerINN?: number | undefined;
    worker?: string | undefined;
    location?: DeviceLocation | undefined;
    pressure?: string | undefined;
    temperature?: number | undefined;
    humidity?: number | undefined;
    measurementMin?: number | undefined;
    measurementMax?: number | undefined;
    measurementUnit?: string | undefined;
    accuracy?: number | undefined;
    device?: Device | undefined;
    verificationMethod?: VerificationMethod | undefined;
    etalons?: Etalon[] | undefined;

    constructor(data?: IFailedInitialVerification) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.deviceTypeNumber = _data["deviceTypeNumber"];
            this.deviceSerial = _data["deviceSerial"];
            this.owner = _data["owner"];
            this.verificationTypeName = _data["verificationTypeName"];
            this.verificationDate = _data["verificationDate"] ? new Date(_data["verificationDate"].toString()) : <any>undefined;
            this.failedDocNumber = _data["failedDocNumber"];
            this.verificationGroup = _data["verificationGroup"];
            this.protocolNumber = _data["protocolNumber"];
            this.ownerINN = _data["ownerINN"];
            this.worker = _data["worker"];
            this.location = _data["location"];
            this.pressure = _data["pressure"];
            this.temperature = _data["temperature"];
            this.humidity = _data["humidity"];
            this.measurementMin = _data["measurementMin"];
            this.measurementMax = _data["measurementMax"];
            this.measurementUnit = _data["measurementUnit"];
            this.accuracy = _data["accuracy"];
            this.device = _data["device"] ? Device.fromJS(_data["device"]) : <any>undefined;
            this.verificationMethod = _data["verificationMethod"] ? VerificationMethod.fromJS(_data["verificationMethod"]) : <any>undefined;
            if (Array.isArray(_data["etalons"])) {
                this.etalons = [] as any;
                for (let item of _data["etalons"])
                    this.etalons!.push(Etalon.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): FailedInitialVerification {
        data = typeof data === 'object' ? data : {};
        let result = new FailedInitialVerification();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceTypeNumber"] = this.deviceTypeNumber;
        data["deviceSerial"] = this.deviceSerial;
        data["owner"] = this.owner;
        data["verificationTypeName"] = this.verificationTypeName;
        data["verificationDate"] = this.verificationDate ? formatDate(this.verificationDate) : <any>undefined;
        data["failedDocNumber"] = this.failedDocNumber;
        data["verificationGroup"] = this.verificationGroup;
        data["protocolNumber"] = this.protocolNumber;
        data["ownerINN"] = this.ownerINN;
        data["worker"] = this.worker;
        data["location"] = this.location;
        data["pressure"] = this.pressure;
        data["temperature"] = this.temperature;
        data["humidity"] = this.humidity;
        data["measurementMin"] = this.measurementMin;
        data["measurementMax"] = this.measurementMax;
        data["measurementUnit"] = this.measurementUnit;
        data["accuracy"] = this.accuracy;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["verificationMethod"] = this.verificationMethod ? this.verificationMethod.toJSON() : <any>undefined;
        if (Array.isArray(this.etalons)) {
            data["etalons"] = [];
            for (let item of this.etalons)
                data["etalons"].push(item ? item.toJSON() : <any>undefined);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IFailedInitialVerification extends IDatabaseEntity {
    deviceTypeNumber?: string;
    deviceSerial?: string;
    owner?: string;
    verificationTypeName?: string;
    verificationDate?: Date;
    failedDocNumber?: string;
    verificationGroup?: VerificationGroup | undefined;
    protocolNumber?: string | undefined;
    ownerINN?: number | undefined;
    worker?: string | undefined;
    location?: DeviceLocation | undefined;
    pressure?: string | undefined;
    temperature?: number | undefined;
    humidity?: number | undefined;
    measurementMin?: number | undefined;
    measurementMax?: number | undefined;
    measurementUnit?: string | undefined;
    accuracy?: number | undefined;
    device?: Device | undefined;
    verificationMethod?: VerificationMethod | undefined;
    etalons?: Etalon[] | undefined;
}

export class Manometr1Verification extends DatabaseEntity implements IManometr1Verification {
    protocolNumber?: string;
    temperature?: number;
    humidity?: number;
    pressure?: string;
    verificationDate?: Date;
    worker?: string;
    deviceTypeNumber?: string;
    deviceSerial?: string;
    verificationGroup?: VerificationGroup;
    location?: DeviceLocation;
    verifiedUntilDate?: Date;
    initialVerificationName?: string;
    ownerInitialName?: string;
    measurementMin?: number;
    measurementMax?: number;
    measurementUnit?: string;
    validError?: number;
    deviceValues?: number[][];
    etalonValues?: number[][];
    actualError?: number[][];
    actualVariation?: number[];
    deviceId?: string | undefined;
    device?: Device | undefined;
    verificationMethodId?: string | undefined;
    verificationMethod?: VerificationMethod | undefined;
    ownerId?: string | undefined;
    owner?: Owner | undefined;
    etalons?: Etalon[] | undefined;

    constructor(data?: IManometr1Verification) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.protocolNumber = _data["protocolNumber"];
            this.temperature = _data["temperature"];
            this.humidity = _data["humidity"];
            this.pressure = _data["pressure"];
            this.verificationDate = _data["verificationDate"] ? new Date(_data["verificationDate"].toString()) : <any>undefined;
            this.worker = _data["worker"];
            this.deviceTypeNumber = _data["deviceTypeNumber"];
            this.deviceSerial = _data["deviceSerial"];
            this.verificationGroup = _data["verificationGroup"];
            this.location = _data["location"];
            this.verifiedUntilDate = _data["verifiedUntilDate"] ? new Date(_data["verifiedUntilDate"].toString()) : <any>undefined;
            this.initialVerificationName = _data["initialVerificationName"];
            this.ownerInitialName = _data["ownerInitialName"];
            this.measurementMin = _data["measurementMin"];
            this.measurementMax = _data["measurementMax"];
            this.measurementUnit = _data["measurementUnit"];
            this.validError = _data["validError"];
            if (Array.isArray(_data["deviceValues"])) {
                this.deviceValues = [] as any;
                for (let item of _data["deviceValues"])
                    this.deviceValues!.push(item);
            }
            if (Array.isArray(_data["etalonValues"])) {
                this.etalonValues = [] as any;
                for (let item of _data["etalonValues"])
                    this.etalonValues!.push(item);
            }
            if (Array.isArray(_data["actualError"])) {
                this.actualError = [] as any;
                for (let item of _data["actualError"])
                    this.actualError!.push(item);
            }
            if (Array.isArray(_data["actualVariation"])) {
                this.actualVariation = [] as any;
                for (let item of _data["actualVariation"])
                    this.actualVariation!.push(item);
            }
            this.deviceId = _data["deviceId"];
            this.device = _data["device"] ? Device.fromJS(_data["device"]) : <any>undefined;
            this.verificationMethodId = _data["verificationMethodId"];
            this.verificationMethod = _data["verificationMethod"] ? VerificationMethod.fromJS(_data["verificationMethod"]) : <any>undefined;
            this.ownerId = _data["ownerId"];
            this.owner = _data["owner"] ? Owner.fromJS(_data["owner"]) : <any>undefined;
            if (Array.isArray(_data["etalons"])) {
                this.etalons = [] as any;
                for (let item of _data["etalons"])
                    this.etalons!.push(Etalon.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Manometr1Verification {
        data = typeof data === 'object' ? data : {};
        let result = new Manometr1Verification();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["protocolNumber"] = this.protocolNumber;
        data["temperature"] = this.temperature;
        data["humidity"] = this.humidity;
        data["pressure"] = this.pressure;
        data["verificationDate"] = this.verificationDate ? formatDate(this.verificationDate) : <any>undefined;
        data["worker"] = this.worker;
        data["deviceTypeNumber"] = this.deviceTypeNumber;
        data["deviceSerial"] = this.deviceSerial;
        data["verificationGroup"] = this.verificationGroup;
        data["location"] = this.location;
        data["verifiedUntilDate"] = this.verifiedUntilDate ? formatDate(this.verifiedUntilDate) : <any>undefined;
        data["initialVerificationName"] = this.initialVerificationName;
        data["ownerInitialName"] = this.ownerInitialName;
        data["measurementMin"] = this.measurementMin;
        data["measurementMax"] = this.measurementMax;
        data["measurementUnit"] = this.measurementUnit;
        data["validError"] = this.validError;
        if (Array.isArray(this.deviceValues)) {
            data["deviceValues"] = [];
            for (let item of this.deviceValues)
                data["deviceValues"].push(item);
        }
        if (Array.isArray(this.etalonValues)) {
            data["etalonValues"] = [];
            for (let item of this.etalonValues)
                data["etalonValues"].push(item);
        }
        if (Array.isArray(this.actualError)) {
            data["actualError"] = [];
            for (let item of this.actualError)
                data["actualError"].push(item);
        }
        if (Array.isArray(this.actualVariation)) {
            data["actualVariation"] = [];
            for (let item of this.actualVariation)
                data["actualVariation"].push(item);
        }
        data["deviceId"] = this.deviceId;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["verificationMethodId"] = this.verificationMethodId;
        data["verificationMethod"] = this.verificationMethod ? this.verificationMethod.toJSON() : <any>undefined;
        data["ownerId"] = this.ownerId;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        if (Array.isArray(this.etalons)) {
            data["etalons"] = [];
            for (let item of this.etalons)
                data["etalons"].push(item ? item.toJSON() : <any>undefined);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IManometr1Verification extends IDatabaseEntity {
    protocolNumber?: string;
    temperature?: number;
    humidity?: number;
    pressure?: string;
    verificationDate?: Date;
    worker?: string;
    deviceTypeNumber?: string;
    deviceSerial?: string;
    verificationGroup?: VerificationGroup;
    location?: DeviceLocation;
    verifiedUntilDate?: Date;
    initialVerificationName?: string;
    ownerInitialName?: string;
    measurementMin?: number;
    measurementMax?: number;
    measurementUnit?: string;
    validError?: number;
    deviceValues?: number[][];
    etalonValues?: number[][];
    actualError?: number[][];
    actualVariation?: number[];
    deviceId?: string | undefined;
    device?: Device | undefined;
    verificationMethodId?: string | undefined;
    verificationMethod?: VerificationMethod | undefined;
    ownerId?: string | undefined;
    owner?: Owner | undefined;
    etalons?: Etalon[] | undefined;
}

export class Davlenie1Verification extends DatabaseEntity implements IDavlenie1Verification {
    protocolNumber?: string;
    temperature?: number;
    humidity?: number;
    pressure?: string;
    verificationDate?: Date;
    worker?: string;
    deviceTypeNumber?: string;
    deviceSerial?: string;
    verificationGroup?: VerificationGroup;
    location?: DeviceLocation;
    verifiedUntilDate?: Date;
    initialVerificationName?: string;
    ownerInitialName?: string;
    measurementMin?: number;
    measurementMax?: number;
    measurementUnit?: string;
    pressureInputs?: number[];
    etalonValues?: number[];
    deviceValues?: number[][];
    actualError?: number[][];
    validError?: number;
    variations?: number[];
    deviceId?: string | undefined;
    device?: Device | undefined;
    verificationMethodId?: string | undefined;
    verificationMethod?: VerificationMethod | undefined;
    ownerId?: string | undefined;
    owner?: Owner | undefined;
    etalons?: Etalon[] | undefined;

    constructor(data?: IDavlenie1Verification) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.protocolNumber = _data["protocolNumber"];
            this.temperature = _data["temperature"];
            this.humidity = _data["humidity"];
            this.pressure = _data["pressure"];
            this.verificationDate = _data["verificationDate"] ? new Date(_data["verificationDate"].toString()) : <any>undefined;
            this.worker = _data["worker"];
            this.deviceTypeNumber = _data["deviceTypeNumber"];
            this.deviceSerial = _data["deviceSerial"];
            this.verificationGroup = _data["verificationGroup"];
            this.location = _data["location"];
            this.verifiedUntilDate = _data["verifiedUntilDate"] ? new Date(_data["verifiedUntilDate"].toString()) : <any>undefined;
            this.initialVerificationName = _data["initialVerificationName"];
            this.ownerInitialName = _data["ownerInitialName"];
            this.measurementMin = _data["measurementMin"];
            this.measurementMax = _data["measurementMax"];
            this.measurementUnit = _data["measurementUnit"];
            if (Array.isArray(_data["pressureInputs"])) {
                this.pressureInputs = [] as any;
                for (let item of _data["pressureInputs"])
                    this.pressureInputs!.push(item);
            }
            if (Array.isArray(_data["etalonValues"])) {
                this.etalonValues = [] as any;
                for (let item of _data["etalonValues"])
                    this.etalonValues!.push(item);
            }
            if (Array.isArray(_data["deviceValues"])) {
                this.deviceValues = [] as any;
                for (let item of _data["deviceValues"])
                    this.deviceValues!.push(item);
            }
            if (Array.isArray(_data["actualError"])) {
                this.actualError = [] as any;
                for (let item of _data["actualError"])
                    this.actualError!.push(item);
            }
            this.validError = _data["validError"];
            if (Array.isArray(_data["variations"])) {
                this.variations = [] as any;
                for (let item of _data["variations"])
                    this.variations!.push(item);
            }
            this.deviceId = _data["deviceId"];
            this.device = _data["device"] ? Device.fromJS(_data["device"]) : <any>undefined;
            this.verificationMethodId = _data["verificationMethodId"];
            this.verificationMethod = _data["verificationMethod"] ? VerificationMethod.fromJS(_data["verificationMethod"]) : <any>undefined;
            this.ownerId = _data["ownerId"];
            this.owner = _data["owner"] ? Owner.fromJS(_data["owner"]) : <any>undefined;
            if (Array.isArray(_data["etalons"])) {
                this.etalons = [] as any;
                for (let item of _data["etalons"])
                    this.etalons!.push(Etalon.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Davlenie1Verification {
        data = typeof data === 'object' ? data : {};
        let result = new Davlenie1Verification();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["protocolNumber"] = this.protocolNumber;
        data["temperature"] = this.temperature;
        data["humidity"] = this.humidity;
        data["pressure"] = this.pressure;
        data["verificationDate"] = this.verificationDate ? formatDate(this.verificationDate) : <any>undefined;
        data["worker"] = this.worker;
        data["deviceTypeNumber"] = this.deviceTypeNumber;
        data["deviceSerial"] = this.deviceSerial;
        data["verificationGroup"] = this.verificationGroup;
        data["location"] = this.location;
        data["verifiedUntilDate"] = this.verifiedUntilDate ? formatDate(this.verifiedUntilDate) : <any>undefined;
        data["initialVerificationName"] = this.initialVerificationName;
        data["ownerInitialName"] = this.ownerInitialName;
        data["measurementMin"] = this.measurementMin;
        data["measurementMax"] = this.measurementMax;
        data["measurementUnit"] = this.measurementUnit;
        if (Array.isArray(this.pressureInputs)) {
            data["pressureInputs"] = [];
            for (let item of this.pressureInputs)
                data["pressureInputs"].push(item);
        }
        if (Array.isArray(this.etalonValues)) {
            data["etalonValues"] = [];
            for (let item of this.etalonValues)
                data["etalonValues"].push(item);
        }
        if (Array.isArray(this.deviceValues)) {
            data["deviceValues"] = [];
            for (let item of this.deviceValues)
                data["deviceValues"].push(item);
        }
        if (Array.isArray(this.actualError)) {
            data["actualError"] = [];
            for (let item of this.actualError)
                data["actualError"].push(item);
        }
        data["validError"] = this.validError;
        if (Array.isArray(this.variations)) {
            data["variations"] = [];
            for (let item of this.variations)
                data["variations"].push(item);
        }
        data["deviceId"] = this.deviceId;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["verificationMethodId"] = this.verificationMethodId;
        data["verificationMethod"] = this.verificationMethod ? this.verificationMethod.toJSON() : <any>undefined;
        data["ownerId"] = this.ownerId;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        if (Array.isArray(this.etalons)) {
            data["etalons"] = [];
            for (let item of this.etalons)
                data["etalons"].push(item ? item.toJSON() : <any>undefined);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IDavlenie1Verification extends IDatabaseEntity {
    protocolNumber?: string;
    temperature?: number;
    humidity?: number;
    pressure?: string;
    verificationDate?: Date;
    worker?: string;
    deviceTypeNumber?: string;
    deviceSerial?: string;
    verificationGroup?: VerificationGroup;
    location?: DeviceLocation;
    verifiedUntilDate?: Date;
    initialVerificationName?: string;
    ownerInitialName?: string;
    measurementMin?: number;
    measurementMax?: number;
    measurementUnit?: string;
    pressureInputs?: number[];
    etalonValues?: number[];
    deviceValues?: number[][];
    actualError?: number[][];
    validError?: number;
    variations?: number[];
    deviceId?: string | undefined;
    device?: Device | undefined;
    verificationMethodId?: string | undefined;
    verificationMethod?: VerificationMethod | undefined;
    ownerId?: string | undefined;
    owner?: Owner | undefined;
    etalons?: Etalon[] | undefined;
}

export class ServicePaginatedResultOfVerificationMethodDTO implements IServicePaginatedResultOfVerificationMethodDTO {
    message?: string | undefined;
    error?: string | undefined;
    data?: PaginatedListOfVerificationMethodDTO | undefined;

    constructor(data?: IServicePaginatedResultOfVerificationMethodDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.error = _data["error"];
            this.data = _data["data"] ? PaginatedListOfVerificationMethodDTO.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServicePaginatedResultOfVerificationMethodDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePaginatedResultOfVerificationMethodDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["error"] = this.error;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IServicePaginatedResultOfVerificationMethodDTO {
    message?: string | undefined;
    error?: string | undefined;
    data?: PaginatedListOfVerificationMethodDTO | undefined;
}

export class PaginatedListOfVerificationMethodDTO implements IPaginatedListOfVerificationMethodDTO {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: VerificationMethodDTO[];

    constructor(data?: IPaginatedListOfVerificationMethodDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(VerificationMethodDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListOfVerificationMethodDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfVerificationMethodDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IPaginatedListOfVerificationMethodDTO {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: VerificationMethodDTO[];
}

export class VerificationMethodDTO implements IVerificationMethodDTO {
    id?: string;
    aliases?: string[];
    description?: string;
    files?: string[];
    typeNumbers?: string[];

    constructor(data?: IVerificationMethodDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["aliases"])) {
                this.aliases = [] as any;
                for (let item of _data["aliases"])
                    this.aliases!.push(item);
            }
            this.description = _data["description"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(item);
            }
            if (Array.isArray(_data["typeNumbers"])) {
                this.typeNumbers = [] as any;
                for (let item of _data["typeNumbers"])
                    this.typeNumbers!.push(item);
            }
        }
    }

    static fromJS(data: any): VerificationMethodDTO {
        data = typeof data === 'object' ? data : {};
        let result = new VerificationMethodDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.aliases)) {
            data["aliases"] = [];
            for (let item of this.aliases)
                data["aliases"].push(item);
        }
        data["description"] = this.description;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item);
        }
        if (Array.isArray(this.typeNumbers)) {
            data["typeNumbers"] = [];
            for (let item of this.typeNumbers)
                data["typeNumbers"].push(item);
        }
        return data;
    }
}

export interface IVerificationMethodDTO {
    id?: string;
    aliases?: string[];
    description?: string;
    files?: string[];
    typeNumbers?: string[];
}

export class ServicePaginatedResultOfPossibleVrfMethodDTO implements IServicePaginatedResultOfPossibleVrfMethodDTO {
    message?: string | undefined;
    error?: string | undefined;
    data?: PaginatedListOfPossibleVrfMethodDTO | undefined;

    constructor(data?: IServicePaginatedResultOfPossibleVrfMethodDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.error = _data["error"];
            this.data = _data["data"] ? PaginatedListOfPossibleVrfMethodDTO.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServicePaginatedResultOfPossibleVrfMethodDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePaginatedResultOfPossibleVrfMethodDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["error"] = this.error;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IServicePaginatedResultOfPossibleVrfMethodDTO {
    message?: string | undefined;
    error?: string | undefined;
    data?: PaginatedListOfPossibleVrfMethodDTO | undefined;
}

export class PaginatedListOfPossibleVrfMethodDTO implements IPaginatedListOfPossibleVrfMethodDTO {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: PossibleVrfMethodDTO[];

    constructor(data?: IPaginatedListOfPossibleVrfMethodDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PossibleVrfMethodDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListOfPossibleVrfMethodDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfPossibleVrfMethodDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IPaginatedListOfPossibleVrfMethodDTO {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: PossibleVrfMethodDTO[];
}

export class PossibleVrfMethodDTO implements IPossibleVrfMethodDTO {
    deviceTypeNumber?: string;
    deviceTypeInfo?: string;
    methodUrls?: string[];
    specUrls?: string[];
    aliasGroups?: PossibleVrfMethodAliasGroupDTO[];

    constructor(data?: IPossibleVrfMethodDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceTypeNumber = _data["deviceTypeNumber"];
            this.deviceTypeInfo = _data["deviceTypeInfo"];
            if (Array.isArray(_data["methodUrls"])) {
                this.methodUrls = [] as any;
                for (let item of _data["methodUrls"])
                    this.methodUrls!.push(item);
            }
            if (Array.isArray(_data["specUrls"])) {
                this.specUrls = [] as any;
                for (let item of _data["specUrls"])
                    this.specUrls!.push(item);
            }
            if (Array.isArray(_data["aliasGroups"])) {
                this.aliasGroups = [] as any;
                for (let item of _data["aliasGroups"])
                    this.aliasGroups!.push(PossibleVrfMethodAliasGroupDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PossibleVrfMethodDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PossibleVrfMethodDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceTypeNumber"] = this.deviceTypeNumber;
        data["deviceTypeInfo"] = this.deviceTypeInfo;
        if (Array.isArray(this.methodUrls)) {
            data["methodUrls"] = [];
            for (let item of this.methodUrls)
                data["methodUrls"].push(item);
        }
        if (Array.isArray(this.specUrls)) {
            data["specUrls"] = [];
            for (let item of this.specUrls)
                data["specUrls"].push(item);
        }
        if (Array.isArray(this.aliasGroups)) {
            data["aliasGroups"] = [];
            for (let item of this.aliasGroups)
                data["aliasGroups"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IPossibleVrfMethodDTO {
    deviceTypeNumber?: string;
    deviceTypeInfo?: string;
    methodUrls?: string[];
    specUrls?: string[];
    aliasGroups?: PossibleVrfMethodAliasGroupDTO[];
}

export class PossibleVrfMethodAliasGroupDTO implements IPossibleVrfMethodAliasGroupDTO {
    aliases?: PossibleVrfMethodAliasDTO[];
    modifications?: string[];
    dates?: YearMonth[];

    constructor(data?: IPossibleVrfMethodAliasGroupDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["aliases"])) {
                this.aliases = [] as any;
                for (let item of _data["aliases"])
                    this.aliases!.push(PossibleVrfMethodAliasDTO.fromJS(item));
            }
            if (Array.isArray(_data["modifications"])) {
                this.modifications = [] as any;
                for (let item of _data["modifications"])
                    this.modifications!.push(item);
            }
            if (Array.isArray(_data["dates"])) {
                this.dates = [] as any;
                for (let item of _data["dates"])
                    this.dates!.push(YearMonth.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PossibleVrfMethodAliasGroupDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PossibleVrfMethodAliasGroupDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.aliases)) {
            data["aliases"] = [];
            for (let item of this.aliases)
                data["aliases"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.modifications)) {
            data["modifications"] = [];
            for (let item of this.modifications)
                data["modifications"].push(item);
        }
        if (Array.isArray(this.dates)) {
            data["dates"] = [];
            for (let item of this.dates)
                data["dates"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IPossibleVrfMethodAliasGroupDTO {
    aliases?: PossibleVrfMethodAliasDTO[];
    modifications?: string[];
    dates?: YearMonth[];
}

export class PossibleVrfMethodAliasDTO implements IPossibleVrfMethodAliasDTO {
    exists?: boolean;
    alias?: string;

    constructor(data?: IPossibleVrfMethodAliasDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exists = _data["exists"];
            this.alias = _data["alias"];
        }
    }

    static fromJS(data: any): PossibleVrfMethodAliasDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PossibleVrfMethodAliasDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exists"] = this.exists;
        data["alias"] = this.alias;
        return data;
    }
}

export interface IPossibleVrfMethodAliasDTO {
    exists?: boolean;
    alias?: string;
}

export enum ShowVMethods {
    Новые = "Новые",
    Частичные = "Частичные",
    Все = "Все",
}

export class AddVerificationMethodRequest implements IAddVerificationMethodRequest {
    description?: string;
    aliases?: string[];
    checkups?: { [key: string]: string; };

    constructor(data?: IAddVerificationMethodRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            if (Array.isArray(_data["aliases"])) {
                this.aliases = [] as any;
                for (let item of _data["aliases"])
                    this.aliases!.push(item);
            }
            if (_data["checkups"]) {
                this.checkups = {} as any;
                for (let key in _data["checkups"]) {
                    if (_data["checkups"].hasOwnProperty(key))
                        (<any>this.checkups)![key] = _data["checkups"][key];
                }
            }
        }
    }

    static fromJS(data: any): AddVerificationMethodRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddVerificationMethodRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        if (Array.isArray(this.aliases)) {
            data["aliases"] = [];
            for (let item of this.aliases)
                data["aliases"].push(item);
        }
        if (this.checkups) {
            data["checkups"] = {};
            for (let key in this.checkups) {
                if (this.checkups.hasOwnProperty(key))
                    (<any>data["checkups"])[key] = (<any>this.checkups)[key];
            }
        }
        return data;
    }
}

export interface IAddVerificationMethodRequest {
    description?: string;
    aliases?: string[];
    checkups?: { [key: string]: string; };
}

export class ServicePaginatedResultOfSuccessInitialVerificationDto implements IServicePaginatedResultOfSuccessInitialVerificationDto {
    message?: string | undefined;
    error?: string | undefined;
    data?: PaginatedListOfSuccessInitialVerificationDto | undefined;

    constructor(data?: IServicePaginatedResultOfSuccessInitialVerificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.error = _data["error"];
            this.data = _data["data"] ? PaginatedListOfSuccessInitialVerificationDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServicePaginatedResultOfSuccessInitialVerificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServicePaginatedResultOfSuccessInitialVerificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["error"] = this.error;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IServicePaginatedResultOfSuccessInitialVerificationDto {
    message?: string | undefined;
    error?: string | undefined;
    data?: PaginatedListOfSuccessInitialVerificationDto | undefined;
}

export class PaginatedListOfSuccessInitialVerificationDto implements IPaginatedListOfSuccessInitialVerificationDto {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: SuccessInitialVerificationDto[];

    constructor(data?: IPaginatedListOfSuccessInitialVerificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SuccessInitialVerificationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedListOfSuccessInitialVerificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfSuccessInitialVerificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IPaginatedListOfSuccessInitialVerificationDto {
    pageIndex?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    totalCount?: number;
    items?: SuccessInitialVerificationDto[];
}

export class SuccessInitialVerificationDto implements ISuccessInitialVerificationDto {
    deviceTypeNumber?: string;
    deviceSerial?: string;
    verificationDate?: Date;
    verifiedUntilDate?: Date;
    verificationTypeName?: string;
    owner?: string;
    id?: string;
    deviceTypeInfo?: string;
    etalons?: string[];
    verificationGroup?: VerificationGroup | undefined;
    protocolNumber?: string | undefined;
    ownerINN?: number | undefined;
    worker?: string | undefined;
    location?: DeviceLocation | undefined;
    pressure?: string | undefined;
    temperature?: number | undefined;
    humidity?: number | undefined;
    measurementMin?: number | undefined;
    measurementMax?: number | undefined;
    measurementUnit?: string | undefined;
    accuracy?: number | undefined;
    verificationMethodInfo?: string | undefined;

    constructor(data?: ISuccessInitialVerificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceTypeNumber = _data["deviceTypeNumber"];
            this.deviceSerial = _data["deviceSerial"];
            this.verificationDate = _data["verificationDate"] ? new Date(_data["verificationDate"].toString()) : <any>undefined;
            this.verifiedUntilDate = _data["verifiedUntilDate"] ? new Date(_data["verifiedUntilDate"].toString()) : <any>undefined;
            this.verificationTypeName = _data["verificationTypeName"];
            this.owner = _data["owner"];
            this.id = _data["id"];
            this.deviceTypeInfo = _data["deviceTypeInfo"];
            if (Array.isArray(_data["etalons"])) {
                this.etalons = [] as any;
                for (let item of _data["etalons"])
                    this.etalons!.push(item);
            }
            this.verificationGroup = _data["verificationGroup"];
            this.protocolNumber = _data["protocolNumber"];
            this.ownerINN = _data["ownerINN"];
            this.worker = _data["worker"];
            this.location = _data["location"];
            this.pressure = _data["pressure"];
            this.temperature = _data["temperature"];
            this.humidity = _data["humidity"];
            this.measurementMin = _data["measurementMin"];
            this.measurementMax = _data["measurementMax"];
            this.measurementUnit = _data["measurementUnit"];
            this.accuracy = _data["accuracy"];
            this.verificationMethodInfo = _data["verificationMethodInfo"];
        }
    }

    static fromJS(data: any): SuccessInitialVerificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SuccessInitialVerificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceTypeNumber"] = this.deviceTypeNumber;
        data["deviceSerial"] = this.deviceSerial;
        data["verificationDate"] = this.verificationDate ? formatDate(this.verificationDate) : <any>undefined;
        data["verifiedUntilDate"] = this.verifiedUntilDate ? formatDate(this.verifiedUntilDate) : <any>undefined;
        data["verificationTypeName"] = this.verificationTypeName;
        data["owner"] = this.owner;
        data["id"] = this.id;
        data["deviceTypeInfo"] = this.deviceTypeInfo;
        if (Array.isArray(this.etalons)) {
            data["etalons"] = [];
            for (let item of this.etalons)
                data["etalons"].push(item);
        }
        data["verificationGroup"] = this.verificationGroup;
        data["protocolNumber"] = this.protocolNumber;
        data["ownerINN"] = this.ownerINN;
        data["worker"] = this.worker;
        data["location"] = this.location;
        data["pressure"] = this.pressure;
        data["temperature"] = this.temperature;
        data["humidity"] = this.humidity;
        data["measurementMin"] = this.measurementMin;
        data["measurementMax"] = this.measurementMax;
        data["measurementUnit"] = this.measurementUnit;
        data["accuracy"] = this.accuracy;
        data["verificationMethodInfo"] = this.verificationMethodInfo;
        return data;
    }
}

export interface ISuccessInitialVerificationDto {
    deviceTypeNumber?: string;
    deviceSerial?: string;
    verificationDate?: Date;
    verifiedUntilDate?: Date;
    verificationTypeName?: string;
    owner?: string;
    id?: string;
    deviceTypeInfo?: string;
    etalons?: string[];
    verificationGroup?: VerificationGroup | undefined;
    protocolNumber?: string | undefined;
    ownerINN?: number | undefined;
    worker?: string | undefined;
    location?: DeviceLocation | undefined;
    pressure?: string | undefined;
    temperature?: number | undefined;
    humidity?: number | undefined;
    measurementMin?: number | undefined;
    measurementMax?: number | undefined;
    measurementUnit?: string | undefined;
    accuracy?: number | undefined;
    verificationMethodInfo?: string | undefined;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}